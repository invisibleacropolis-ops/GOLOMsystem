<h1>Turn-Based Grid Timespace Manual</h1>
<p><code>turn_timespace.gd</code> defines the <code>TurnBasedGridTimespace</code> module, which orchestrates the tactical timeline of the game. It is the central authority for managing initiative order, action points (AP), overwatch reactions, explicit reaction windows, status ticking, and the serialization of the game state for replay support.</p>
<h2>Responsibilities</h2>
<ul>
<li>Maintain the game's round and turn state via an internal state machine.</li>
<li>Track actors with initiative, action points, and positions on a <code>LogicGridMap</code>.</li>
<li>Emit signals (<code>round_started</code>, <code>turn_started</code>, <code>ap_changed</code>, <code>action_performed</code>, etc.) to allow UI or AI layers to react to game flow changes.</li>
<li>Register actions with validators and executors through <code>register_action()</code> and invoke them via <code>perform()</code>.</li>
<li>Apply and tick status effects on actors and tiles, delegating to the <code>Statuses</code> module and emitting callbacks to update <code>Attributes</code>.</li>
<li>Enable deterministic snapshots of the entire timeline state with <code>create_snapshot()</code> and <code>to_dict()</code> / <code>from_dict()</code>.</li>
<li>Provide serialization and replay functionality for the <code>event_log</code>.</li>
</ul>
<h2>Core Concepts and API Details</h2>
<p>The <code>TurnBasedGridTimespace</code> module is the heart of the turn-based combat system. It ensures that all actions and events occur in a predictable and ordered manner.</p>
<h3>Class: <code>TurnBasedGridTimespace</code> (inherits from <code>Node</code>)</h3>
<p>As a <code>Node</code>, <code>TurnBasedGridTimespace</code> can be integrated into your game's scene tree, typically as part of a <code>RuntimeServices</code> aggregation.</p>
<h4>Members</h4>
<ul>
<li><strong><code>state</code></strong> (<code>int</code>, Enum: <code>TurnBasedGridTimespace.State</code>, Default: <code>0</code>): Represents the current state of the turn-based system (e.g., <code>IDLE</code>, <code>ROUND_START</code>, <code>ACTING</code>, <code>REACTION_WINDOWS</code>).</li>
<li><strong><code>grid_map</code></strong> (<code>Resource</code>): A reference to the <code>LogicGridMap</code> instance. This is crucial for the timespace to understand the spatial layout of the game world and validate movements.</li>
<li><strong><code>_actors</code></strong> (<code>Array</code>, Default: <code>[]</code>): An internal array tracking all actors currently participating in the turn order.</li>
<li><strong><code>_objects</code></strong> (<code>Array</code>, Default: <code>[]</code>): An internal array tracking static objects that participate in the timeline.</li>
<li><strong><code>_actor_status</code></strong> (<code>Dictionary</code>, Default: <code>{}</code>): Internal tracking of actor statuses.</li>
<li><strong><code>_tile_status</code></strong> (<code>Dictionary</code>, Default: <code>{}</code>): Internal tracking of tile statuses.</li>
<li><strong><code>event_log</code></strong> (<code>Array</code>, Default: <code>[]</code>): An internal log for recording events related to the timespace, useful for debugging and replay.</li>
<li><strong><code>_actions</code></strong> (<code>Dictionary</code>, Default: <code>{}</code>): Stores registered action definitions.</li>
<li><strong><code>reaction_watchers</code></strong> (<code>Callable[]</code>, Default: <code>[]</code>): A list of callables that are notified when reaction windows open.</li>
</ul>
<h4>Methods</h4>
<ul>
<li><strong><code>add_actor(actor: Object, initiative: int, action_points: int, pos: Vector2i, tie_break: int = -1) -&gt; void</code></strong>
    Adds an <code>actor</code> to the turn order. The actor is sorted into the initiative queue based on its <code>initiative</code> value.<ul>
<li><code>actor</code>: The game object (e.g., <code>BaseActor</code>) to add.</li>
<li><code>initiative</code>: An integer determining turn order (higher values act first).</li>
<li><code>action_points</code>: The initial action points for the actor.</li>
<li><code>pos</code>: The actor's starting <code>Vector2i</code> position on the grid.</li>
<li><code>tie_break</code>: An optional integer for deterministic tie-breaking in initiative.</li>
</ul>
</li>
<li><strong><code>start_round() -&gt; void</code></strong>
    Resets action points for all actors and initiates a new round. This method triggers the <code>round_started</code> signal.</li>
<li><strong><code>end_turn() -&gt; void</code></strong>
    Advances the timeline to the next actor in the initiative order. This method triggers the <code>turn_ended</code> signal for the current actor and prepares for the next turn.</li>
<li><strong><code>get_current_actor() -&gt; Object</code></strong>
    Returns the <code>Object</code> representing the actor whose turn is currently active.</li>
<li><strong><code>move_current_actor(to: Vector2i) -&gt; bool</code></strong>
    A convenience method for performing the registered "move" action for the current actor. It delegates to the underlying <code>LogicGridMap</code> for spatial updates.<ul>
<li><code>to</code>: The target <code>Vector2i</code> position for the move.</li>
<li><strong>Returns:</strong> <code>true</code> if the move was successful, <code>false</code> otherwise.</li>
</ul>
</li>
<li><strong><code>add_overwatcher(actor: Object, once_per_turn: bool = true) -&gt; void</code></strong>
    Registers an <code>actor</code> to react when others move into its line of sight. This is part of the reaction system.</li>
<li><strong><code>register_reaction_watcher(cb: Callable) -&gt; void</code></strong>
    Allows external systems to subscribe a <code>Callable</code> that will be invoked when reaction windows open, providing details about the reaction opportunity.</li>
<li><strong><code>serialize_event_log() -&gt; String</code></strong>
    Serializes the internal <code>event_log</code> into a JSON string, suitable for saving or network transmission.</li>
<li><strong><code>replay_event_log(json: String, handler: Callable) -&gt; void</code></strong>
    Replays a sequence of events from a serialized JSON string, invoking the provided <code>handler</code> for each event. This is crucial for deterministic replays.</li>
<li><strong><code>apply_status_to_actor(actor: Object, status: String, duration: int = 0, timing: String = "turn_start") -&gt; void</code></strong>
    Applies a status effect to an <code>actor</code>. This method delegates to the <code>Statuses</code> module.<ul>
<li><code>actor</code>: The actor to apply the status to.</li>
<li><code>status</code>: The ID of the status to apply.</li>
<li><code>duration</code>: How long the status lasts (0 for permanent).</li>
<li><code>timing</code>: When the status effect is evaluated (e.g., "turn_start", "turn_end").</li>
</ul>
</li>
<li><strong><code>create_snapshot() -&gt; Dictionary</code></strong>
    Produces a serializable <code>Dictionary</code> capturing the entire current state of the timeline, useful for saving/loading game progress.</li>
<li><strong><code>to_dict() -&gt; Dictionary</code></strong> / <strong><code>from_dict(data: Dictionary) -&gt; void</code></strong>
    Methods for serializing and deserializing the timespace's state to/from a dictionary.</li>
<li><strong><code>register_action(id: String, cost: int, tags: Array, validator: Callable, executor: Callable) -&gt; void</code></strong>
    Registers an action definition with the timespace.<ul>
<li><code>id</code>: Unique ID for the action.</li>
<li><code>cost</code>: AP cost to perform.</li>
<li><code>tags</code>: Array of tags for the action.</li>
<li><code>validator</code>: A <code>Callable</code> to check if the action can be performed.</li>
<li><code>executor</code>: A <code>Callable</code> to execute the action's effects.</li>
</ul>
</li>
<li><strong><code>can_perform(actor: Object, action_id: String, payload: Variant = null) -&gt; bool</code></strong>
    Checks if an actor can perform a registered action, using the action's validator.</li>
<li><strong><code>perform(actor: Object, action_id: String, payload: Variant = null) -&gt; bool</code></strong>
    Executes a registered action, using the action's executor.</li>
</ul>
<h4>Signals</h4>
<ul>
<li><strong><code>round_started()</code></strong>: Emitted when a new round begins.</li>
<li><strong><code>round_ended()</code></strong>: Emitted when a round ends.</li>
<li><strong><code>battle_over(faction: Variant)</code></strong>: Emitted when all actors of a faction are defeated.</li>
<li><strong><code>turn_started(actor: Variant)</code></strong>: Fired at the start of an actor's turn.</li>
<li><strong><code>turn_ended(actor: Variant)</code></strong>: Fired after an actor finishes its turn.</li>
<li><strong><code>ap_changed(actor: Variant, old: Variant, new: Variant)</code></strong>: Emitted when an actor's action points change.</li>
<li><strong><code>action_performed(actor: Variant, action_id: Variant, payload: Variant)</code></strong>: Emitted when an action is successfully executed.</li>
<li><strong><code>status_applied(target: Variant, status: Variant)</code></strong>: Emitted when a status is applied (delegated from <code>Statuses</code>).</li>
<li><strong><code>status_removed(target: Variant, status: Variant)</code></strong>: Emitted when a status is removed (delegated from <code>Statuses</code>).</li>
<li><strong><code>damage_applied(attacker: Variant, defender: Variant, amount: Variant)</code></strong>: Emitted when damage is dealt.</li>
<li><strong><code>reaction_triggered(actor: Variant, data: Variant)</code></strong>: Emitted when a reaction opportunity occurs.</li>
<li><strong><code>timespace_snapshot_created(snapshot: Variant)</code></strong>: Emitted when a game state snapshot is created.</li>
</ul>
<h2>Integration Notes</h2>
<ul>
<li><strong>Deterministic Initiative:</strong> For consistent and repeatable test results, always seed the random number generator (<code>_rng</code> member) if you are using it for initiative ordering. This ensures that the same sequence of turns occurs every time.</li>
<li><strong>Data-Driven Actions:</strong> Actions are defined in a data-driven manner. The <code>validator</code> and <code>executor</code> parameters of <code>register_action()</code> are <code>Callable</code> objects. This allows you to inject game-specific logic (e.g., a function in another script) for validating and executing actions, making the system highly flexible.</li>
<li><strong>Event Logging for Audit and Replay:</strong> The <code>event_log</code> is a powerful feature for debugging and replay functionality. Use <code>serialize_event_log()</code> to save the entire sequence of events, which can then be replayed later using <code>replay_event_log()</code> to perfectly recreate a game session.</li>
<li><strong>Status Tick Windows:</strong> Status effects are evaluated at specific timing windows (<code>round_start</code>, <code>turn_start</code>, <code>turn_end</code>). When <code>status_removed</code> is emitted (from the <code>Statuses</code> module, often triggered by <code>timespace.tick_statuses()</code>), ensure that any external modifiers applied by that status are cleanly removed from the <code>Attributes</code> module.</li>
</ul>
<h2>Testing</h2>
<p>The <code>TurnBasedGridTimespace</code> module includes extensive self-tests covering various aspects of its functionality:</p>
<ul>
<li><strong>Ordering:</strong> Verifies correct initiative order.</li>
<li><strong>AP Spend:</strong> Ensures action points are correctly deducted.</li>
<li><strong>Overwatch:</strong> Tests the overwatch reaction system.</li>
<li><strong>Reaction Windows:</strong> Validates the queuing and resolution of reactions.</li>
<li><strong>Status Durations:</strong> Confirms that status effects tick down and expire correctly.</li>
<li><strong>Serialization:</strong> Checks that the game state can be saved and loaded accurately.</li>
<li><strong>Event Log Schema:</strong> Ensures that events are logged in a consistent and usable format.</li>
</ul>
<p>You can run these tests headlessly via the shared test runner:</p>
<pre><code class="language-bash">godot4 --headless --path . --script scripts/test_runner.gd -- --module=turn_timespace
</code></pre>