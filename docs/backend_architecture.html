<h1>Backend Architecture</h1>
<p>This document outlines how Golom's tactical backend modules communicate during a turn, providing a comprehensive understanding for an entry-level engineer.</p>
<h2>Data Flow Overview</h2>
<p>The diagram below illustrates the core modules and their primary communication channels. Each module is designed to be loosely coupled, interacting primarily through signals and well-defined method calls, with all significant events flowing into a central <code>EventBus</code> for logging and analysis.</p>
<pre><code>                      +----------------+
                      |    EventBus    |
                      +--------^-------+
                               |
                               | push()/log_event
+----------------------+-------+----------------------+
|          TurnBasedGridTimespace                      |
|  - Orchestrates turn order, action points, statuses  |
|  - Emits round/turn and AP signals                   |
|  - Records structured events                         |
+----^-----------+-------------+-----------^-----------+
     |           |             |           |
     |           |             |           +-- reaction_triggered (Signal)
     |           |             |                      |
     |           |             |                      v
     |           |             |                +------------+
     |           |             |                | Reactions  |
     |           |             |                | - Manages queued reactions |
     |           |             |                +------------+
     |           |     status_applied/removed (Signals)
     |           v             |
     |     +-----------+       |
     |     | Statuses  |-------+
     |     | - Applies/removes status effects |
     |     +-----------+       |
     |           ^             |
     |           | modifiers   |
     |       +-----------+     |
     |       | Attributes|&lt;----+
     |       | - Manages numeric stats &amp; modifiers |
     |       +-----------+
     |           ^
     |           | checks costs (via get_value)
     |     +-----------+
     |     | Abilities |
     |     | - Validates &amp; executes abilities |
     |     +-----------+
     |           ^
     |           | grants (via grant/get_available)
     |     +-----------+
     |     | Loadouts  |
     |     | - Manages actor's available abilities |
     |     +-----------+
     |
move_actor()/LOS (LogicGridMap methods)
     |
     v
+-----------+
|LogicGridMap|
| - Manages spatial data &amp; pathfinding |
+-----------+
</code></pre>
<h2>Module Breakdown and Interactions</h2>
<h3><code>EventBus</code></h3>
<ul>
<li><strong>Purpose:</strong> The <code>EventBus</code> acts as a central, append-only log for all significant game events. It's crucial for debugging, analytics, and enabling deterministic replays of game sessions.</li>
<li><strong>Key API:</strong><ul>
<li><code>push(evt: Dictionary) -&gt; void</code>: Modules use this method to add structured event dictionaries to the log.</li>
<li><code>serialize() -&gt; String</code>: Converts the event log into a string format (e.g., JSON) for saving or transmission.</li>
<li><code>replay(json: String, handler: Callable) -&gt; void</code>: Allows replaying a game session from a serialized log.</li>
</ul>
</li>
<li><strong>Interaction:</strong> Almost all other modules, particularly <code>TurnBasedGridTimespace</code>, push events to the <code>EventBus</code> using its <code>push()</code> or <code>log_event()</code> methods. This ensures a comprehensive record of game state changes.</li>
</ul>
<h3><code>TurnBasedGridTimespace</code></h3>
<ul>
<li><strong>Purpose:</strong> This module is the orchestrator of the tactical turn-based combat. It manages initiative order, action points (AP), and coordinates the flow of rounds and turns.</li>
<li><strong>Key API:</strong><ul>
<li><code>start_round() -&gt; void</code>: Resets AP for all actors and initiates a new round.</li>
<li><code>end_turn() -&gt; void</code>: Advances the turn to the next actor in the initiative order.</li>
<li><code>get_current_actor() -&gt; Object</code>: Returns the actor whose turn is currently active.</li>
<li><code>register_action(id: String, cost: int, tags: Array, validator: Callable, executor: Callable) -&gt; void</code>: Defines actions that actors can perform.</li>
<li><code>can_perform(actor: Object, action_id: String, payload: Variant) -&gt; bool</code>: Checks if an actor can perform a specific action.</li>
<li><code>perform(actor: Object, action_id: String, payload: Variant) -&gt; bool</code>: Executes a registered action.</li>
<li><code>add_actor(actor: Object, initiative: int, action_points: int, pos: Vector2i, tie_break: int) -&gt; void</code>: Adds an actor to the timespace.</li>
<li><code>apply_status_to_actor(actor: Object, status: String, duration: int, timing: String) -&gt; void</code>: Applies a status effect to an actor.</li>
<li><code>damage_applied(attacker: Variant, defender: Variant, amount: Variant)</code> (Signal): Emitted when damage is dealt.</li>
<li><code>round_started()</code> (Signal): Emitted when a new round begins.</li>
<li><code>turn_started(actor: Variant)</code> (Signal): Emitted at the start of an actor's turn.</li>
<li><code>turn_ended(actor: Variant)</code> (Signal): Emitted after an actor finishes its turn.</li>
<li><code>ap_changed(actor: Variant, old: Variant, new: Variant)</code> (Signal): Emitted when an actor's AP changes.</li>
<li><code>action_performed(actor: Variant, action_id: Variant, payload: Variant)</code> (Signal): Emitted when an action is successfully executed.</li>
</ul>
</li>
<li><strong>Interaction:</strong> It's the central hub. It calls methods on <code>Statuses</code> (for ticking and applying effects), <code>Abilities</code> (for executing actions), and <code>LogicGridMap</code> (for spatial updates). It also emits numerous signals that other modules (like UI or <code>Reactions</code>) can listen to.</li>
</ul>
<h3><code>Reactions</code></h3>
<ul>
<li><strong>Purpose:</strong> The <code>Reactions</code> module handles reactive abilities or events that occur in response to specific game state changes (e.g., an "attack of opportunity" when an enemy moves).</li>
<li><strong>Key API:</strong><ul>
<li><code>trigger(actor: Object, data: Variant, priority: int) -&gt; void</code>: Queues a reaction to be resolved.</li>
<li><code>resolve_next() -&gt; Variant</code>: Resolves the next pending reaction.</li>
<li><code>get_pending() -&gt; Array</code>: Returns a list of currently queued reactions.</li>
<li><code>reaction_queued(reaction: Variant)</code> (Signal): Emitted when a reaction is added to the queue.</li>
</ul>
</li>
<li><strong>Interaction:</strong> <code>TurnBasedGridTimespace</code> can trigger reactions (e.g., via <code>_check_overwatch</code> after movement), and the <code>Reactions</code> module manages their resolution.</li>
</ul>
<h3><code>Statuses</code></h3>
<ul>
<li><strong>Purpose:</strong> This module manages temporary or persistent status effects (buffs, debuffs) on actors and even tiles.</li>
<li><strong>Key API:</strong><ul>
<li><code>apply_status(actor: Object, id: String, stacks: int, duration: int, modifiers: Array) -&gt; void</code>: Applies a status effect.</li>
<li><code>tick() -&gt; void</code>: Reduces the duration of all active statuses and removes expired ones.</li>
<li><code>status_applied(actor: Variant, id: Variant)</code> (Signal): Emitted when a status is applied.</li>
<li><code>status_removed(actor: Variant, id: Variant)</code> (Signal): Emitted when a status is removed.</li>
</ul>
</li>
<li><strong>Interaction:</strong> <code>TurnBasedGridTimespace</code> calls <code>tick()</code> on <code>Statuses</code> at appropriate times (e.g., start/end of turn). <code>Statuses</code> interacts with <code>Attributes</code> to apply modifiers associated with status effects.</li>
</ul>
<h3><code>Attributes</code></h3>
<ul>
<li><strong>Purpose:</strong> Manages all numeric statistics (attributes) for actors, including base values, modifiers (additive, multiplicative, percentage), and clamped ranges.</li>
<li><strong>Key API:</strong><ul>
<li><code>set_base(actor: Object, key: String, value: float) -&gt; void</code>: Sets an actor's base attribute value.</li>
<li><code>add_modifier(actor: Object, key: String, add: float, mul: float, source: String, duration: int, perc: float) -&gt; void</code>: Adds a modifier to an attribute.</li>
<li><code>clear_modifiers(actor: Object, source: String) -&gt; void</code>: Removes modifiers from a specific source.</li>
<li><code>get_value(actor: Object, key: String) -&gt; float</code>: <strong>The primary way to query an attribute's effective value</strong>, considering all modifiers and ranges.</li>
<li><code>set_range(key: String, min_value: float, max_value: float) -&gt; void</code>: Defines min/max for an attribute.</li>
</ul>
</li>
<li><strong>Interaction:</strong> <code>Abilities</code> checks costs via <code>Attributes.get_value()</code>. <code>Statuses</code> applies and removes modifiers using <code>Attributes.add_modifier()</code> and <code>Attributes.clear_modifiers()</code>.</li>
</ul>
<h3><code>Abilities</code></h3>
<ul>
<li><strong>Purpose:</strong> Validates and executes active abilities, managing costs, cooldowns, and effects.</li>
<li><strong>Key API:</strong><ul>
<li><code>register_ability(id: String, data: Dictionary) -&gt; void</code>: Adds an ability definition.</li>
<li><code>load_from_file(path: String) -&gt; void</code>: Loads abilities from JSON.</li>
<li><code>can_use(actor: Object, id: String, attrs: Variant) -&gt; bool</code>: Checks if an actor can use an ability (checks cooldowns and costs via <code>Attributes</code>).</li>
<li><code>execute(actor: Object, id: String, target: Variant, attrs: Variant) -&gt; Array</code>: Executes ability logic, deducts resources, sets cooldowns, and returns follow-up abilities.</li>
<li><code>tick_cooldowns() -&gt; void</code>: Decrements all ability cooldowns.</li>
</ul>
</li>
<li><strong>Interaction:</strong> <code>Loadouts</code> determines which abilities an actor has. <code>Abilities</code> uses <code>Attributes</code> to check resource costs and <code>TurnBasedGridTimespace</code> to log events and potentially trigger signals like <code>damage_applied</code>.</li>
</ul>
<h3><code>Loadouts</code></h3>
<ul>
<li><strong>Purpose:</strong> Manages which abilities are available to a specific actor, potentially based on equipment, class, or status effects.</li>
<li><strong>Key API:</strong><ul>
<li><code>grant(actor: Object, ability_id: String) -&gt; void</code>: Grants a specific ability to an actor.</li>
<li><code>get_available(actor: Object) -&gt; String[]</code>: Returns a list of ability IDs available to an actor.</li>
</ul>
</li>
<li><strong>Interaction:</strong> External logic (e.g., UI) queries <code>Loadouts.get_available()</code> to display options. <code>Loadouts</code> might interact with <code>Abilities</code> to ensure granted abilities are properly registered.</li>
</ul>
<h3><code>LogicGridMap</code></h3>
<ul>
<li><strong>Purpose:</strong> Manages the spatial data of the game world, including tile properties, actor positions, and pathfinding. It's the core for anything related to the grid.</li>
<li><strong>Key API:</strong><ul>
<li><code>move_actor(actor: Object, from_pos: Vector2i, to_pos: Vector2i) -&gt; bool</code>: Moves an actor on the grid.</li>
<li><code>has_line_of_sight(from_pos: Vector2i, to_pos: Vector2i) -&gt; bool</code>: Checks if there's an unobstructed line of sight between two points.</li>
<li><code>get_actor_at(pos: Vector2i) -&gt; Variant</code>: Returns the actor at a given position.</li>
<li><code>has_actor_at(pos: Vector2i) -&gt; bool</code>: Checks if an actor is present at a position.</li>
</ul>
</li>
<li><strong>Interaction:</strong> <code>TurnBasedGridTimespace</code> delegates movement actions to <code>LogicGridMap</code>. <code>GridRealtimeRenderer</code> uses <code>LogicGridMap</code> data for visualization.</li>
</ul>
<h2>Typical Turn Sequence: A Detailed Walkthrough</h2>
<p>Understanding the sequence of operations during a turn is key to grasping the backend's flow.</p>
<ol>
<li>
<p><strong>Round Start:</strong></p>
<ul>
<li><code>TurnBasedGridTimespace.start_round()</code> is called.</li>
<li><strong>Logic:</strong> This method resets each actor's action points (AP) for the new round.</li>
<li><strong>Signals:</strong> It emits the <code>round_started</code> signal, notifying any listening systems (e.g., UI, other game logic) that a new round has begun.</li>
<li><strong>Logging:</strong> An event is logged to the <code>EventBus</code> to record the round start.</li>
<li><strong>Status Tick:</strong> Before the first turn, <code>TurnBasedGridTimespace</code> calls <code>Statuses.tick()</code> to process any round-start status effects.</li>
</ul>
</li>
<li>
<p><strong>Turn Begins:</strong></p>
<ul>
<li><code>_begin_actor_turn()</code> (an internal method of <code>TurnBasedGridTimespace</code>) is invoked for the current actor.</li>
<li><strong>Signals:</strong> The <code>turn_started</code> signal is fired, indicating which actor's turn it is.</li>
<li><strong>Status Application:</strong> Any <code>turn_start</code> statuses relevant to the active actor are applied or processed by the <code>Statuses</code> module.</li>
</ul>
</li>
<li>
<p><strong>Ability Selection:</strong></p>
<ul>
<li><strong>Loadouts:</strong> External logic (e.g., the player's UI) queries <code>Loadouts.get_available(actor)</code> to retrieve a list of abilities that the current actor possesses and can potentially use.</li>
<li><strong>Abilities &amp; Attributes:</strong> For each available ability, <code>Abilities.can_use(actor, id, attrs)</code> is called. This method internally interacts with the <code>Attributes</code> service (<code>Attributes.get_value()</code>) to check if the actor has sufficient resources (e.g., Action Points, Mana) and if the ability is off cooldown. This ensures only valid abilities are presented to the player.</li>
</ul>
</li>
<li>
<p><strong>Action Execution:</strong></p>
<ul>
<li>When an actor performs an action (e.g., moving, attacking):</li>
<li><strong>Movement:</strong> If it's a movement action, <code>TurnBasedGridTimespace.move_current_actor()</code> is called. This method then delegates the actual spatial update to <code>LogicGridMap.move_actor()</code>, which handles changing the actor's position on the grid.</li>
<li><strong>AP &amp; Signals:</strong> Regardless of the action, <code>TurnBasedGridTimespace</code> manages the actor's Action Points. Changes to AP trigger the <code>ap_changed</code> signal. A successful action execution also emits an <code>action_performed</code> signal, providing details about the action.</li>
<li><strong>Abilities:</strong> If the action is an ability, <code>Abilities.execute()</code> is called, which handles resource deduction, cooldown tracking, and any immediate effects of the ability.</li>
</ul>
</li>
<li>
<p><strong>Reactions:</strong></p>
<ul>
<li>After an actor completes its movement or action, <code>TurnBasedGridTimespace</code> might call <code>_check_overwatch()</code> (an internal method).</li>
<li><strong>Line of Sight:</strong> This method uses <code>LogicGridMap.has_line_of_sight()</code> to determine if any other actors (watchers) have a clear line of sight to the moved actor.</li>
<li><strong>Triggering Reactions:</strong> If conditions are met (e.g., an enemy enters a watcher's line of sight), a <code>reaction_triggered</code> signal is emitted. This signal is typically listened to by the <code>Reactions</code> module, which then queues and manages the resolution of these reactive abilities (e.g., an "attack of opportunity").</li>
</ul>
</li>
<li>
<p><strong>Status Handling:</strong></p>
<ul>
<li>Throughout the turn, abilities or other game effects can call <code>TurnBasedGridTimespace.apply_status_to_actor()</code>. This method then interacts with the <code>Statuses</code> module to apply the status effect.</li>
<li><strong>Signals:</strong> When a status is applied, the <code>Statuses</code> module emits a <code>status_applied</code> signal. Similarly, when a status expires or is removed, a <code>status_removed</code> signal is emitted.</li>
<li><strong>Duration &amp; Ticking:</strong> <code>Statuses</code> manages the duration of effects. <code>TurnBasedGridTimespace</code> ensures <code>Statuses.tick()</code> is called at appropriate turn or round boundaries to decrement durations and purge expired effects.</li>
</ul>
</li>
<li>
<p><strong>Event Logging:</strong></p>
<ul>
<li>Crucially, throughout this entire sequence, each module (e.g., <code>TurnBasedGridTimespace</code>, <code>Attributes</code>, <code>Abilities</code>) records structured dictionaries representing significant events.</li>
<li><strong>Centralized Log:</strong> These event dictionaries are then pushed to the shared <code>EventBus</code> using its <code>push()</code> method. This creates a chronological, detailed log of everything that happened during the turn, invaluable for debugging, analytics, and game state reconstruction.</li>
</ul>
</li>
<li>
<p><strong>Turn End:</strong></p>
<ul>
<li><code>TurnBasedGridTimespace.end_turn()</code> is called.</li>
<li><strong>Signals:</strong> It emits the <code>turn_ended</code> signal for the current actor.</li>
<li><strong>Status Tick:</strong> Any <code>turn_end</code> statuses are processed by the <code>Statuses</code> module.</li>
<li><strong>Next Actor/Round End:</strong> The <code>TurnBasedGridTimespace</code> then advances to the next actor in the initiative order. If all actors have taken their turn, it signals the end of the round by emitting <code>round_ended</code>.</li>
</ul>
</li>
</ol>
<p>Together, these modules form a loosely coupled backend where signals and method calls coordinate spatial updates, ability usage, and reactive effects, while all significant events flow into a central log. This modular design allows for easier development, testing, and maintenance of complex game logic.</p>