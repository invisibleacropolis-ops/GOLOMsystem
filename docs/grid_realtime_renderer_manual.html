<h1>GridRealtimeRenderer Manual</h1>
<p><code>GridRealtimeRenderer</code> is a high-performance overlay renderer built for tactical grid games. It leverages Godot's <code>MultiMeshInstance2D</code> to efficiently batch tile fills, allowing thousands of per-frame updates without creating individual <code>CanvasItem</code> nodes. This makes it ideal for dynamic visual feedback like highlighting, heatmaps, and various overlays. It also supports numeric channels that can be mapped through a <code>Gradient</code> to display heatmaps.</p>
<h2>Responsibilities</h2>
<ul>
<li>Maintain a static grid of quads sized to <code>cell_size</code> and <code>grid_size</code>.</li>
<li>Provide direct per-cell color fills via <code>set_cell_color()</code> and <code>clear_*()</code> helpers.</li>
<li>Track arbitrary numeric channels and convert them into colors with <code>apply_heatmap()</code>.</li>
<li>Optionally draw grid lines and lightweight overlays such as current actor, paths, areas of effect, and zones of control.</li>
<li>Generate ASCII snapshots of the grid for headless debugging and testing.</li>
<li>Manage GPU-accelerated text labels.</li>
</ul>
<h2>Core Concepts and API Details</h2>
<p>The <code>GridRealtimeRenderer</code> is designed for visual debugging and dynamic UI elements on a grid. Its efficiency comes from batching drawing operations.</p>
<h3>Class: <code>GridRealtimeRenderer</code> (inherits from <code>Node2D</code>)</h3>
<p>As a <code>Node2D</code>, it can be added to your scene tree and positioned relative to your game world.</p>
<h4>Members</h4>
<p>The <code>GridRealtimeRenderer</code> exposes numerous members for configuration and internal state. Here are some key ones:</p>
<ul>
<li><strong><code>enabled_layers</code></strong> (<code>StringName[]</code>, Default: <code>[...]</code>): Controls which visual layers (fill, heat, glyph, stroke, labels, outline) are currently active.</li>
<li><strong><code>layer_opacity_fill</code></strong>, <strong><code>layer_opacity_heat</code></strong>, etc. (<code>float</code>, Default: <code>1.0</code>): Control the transparency of individual visual layers.</li>
<li><strong><code>world_offset</code></strong> (<code>Vector2</code>, Default: <code>Vector2(0, 0)</code>): An offset applied to the entire rendered grid, useful for aligning with a camera or other world elements.</li>
<li><strong><code>cell_size</code></strong> (<code>Vector2</code>, Default: <code>Vector2(48, 48)</code>): The size of each individual grid cell in pixels.</li>
<li><strong><code>grid_size</code></strong> (<code>Vector2i</code>, Default: <code>Vector2i(16, 9)</code>): The dimensions of the grid in cells (width, height).</li>
<li><strong><code>show_grid_lines</code></strong> (<code>bool</code>, Default: <code>true</code>): Toggles the visibility of grid lines.</li>
<li><strong><code>grid_line_thickness</code></strong> (<code>float</code>, Default: <code>1.0</code>): Thickness of the grid lines.</li>
<li><strong><code>grid_line_modulate</code></strong> (<code>Color</code>, Default: <code>Color(1, 1, 1, 0.15)</code>): Color and transparency of the grid lines.</li>
<li><strong><code>enable_fill</code></strong>, <strong><code>enable_heat</code></strong>, <strong><code>enable_marks</code></strong>, <strong><code>enable_strokes</code></strong>, <strong><code>enable_hatch</code></strong> (<code>bool</code>): Enable/disable specific rendering features.</li>
<li><strong><code>opacity_fill</code></strong>, <strong><code>opacity_heat</code></strong>, etc. (<code>float</code>): Opacity settings for various visual elements.</li>
<li><strong><code>label_font</code></strong> (<code>Font</code>): The font resource used for rendering text labels.</li>
<li><strong><code>max_labels</code></strong> (<code>int</code>, Default: <code>256</code>): Maximum number of labels that can be batched.</li>
<li><strong><code>use_gpu_labels</code></strong> (<code>bool</code>, Default: <code>true</code>): Enables/disables GPU-accelerated label rendering.</li>
<li><strong><code>heat_gradient</code></strong> (<code>Gradient</code>, Default: <code>new()</code>): The color gradient used for heatmaps.</li>
<li><strong><code>ascii_update_sec</code></strong> (<code>float</code>, Default: <code>0.5</code>): How often the ASCII debug snapshot is updated.</li>
<li><strong><code>ascii_debug</code></strong> (<code>String</code>): The generated ASCII snapshot of the grid.</li>
<li><strong><code>ascii_use_color</code></strong> (<code>bool</code>, Default: <code>false</code>): If <code>true</code>, the ASCII output will include ANSI color codes.</li>
<li><strong><code>ascii_actor_group</code></strong> (<code>StringName</code>, Default: <code>&amp;"actors"</code>): The group name used to find actors for ASCII representation.</li>
<li><strong><code>ascii_include_actors</code></strong> (<code>bool</code>, Default: <code>true</code>): If <code>true</code>, actors in <code>ascii_actor_group</code> will be included in the ASCII snapshot.</li>
<li><strong><code>input_pos</code></strong> (<code>Vector2i</code>), <strong><code>input_action</code></strong> (<code>String</code>): Exposed properties for headless input simulation.</li>
</ul>
<h4>Methods</h4>
<ul>
<li><strong><code>set_grid_size(w: int, h: int) -&gt; void</code></strong>
    Resizes the grid to the specified <code>w</code> (width) and <code>h</code> (height) in cells. This method rebuilds the underlying multimesh, so it should not be called frequently.</li>
<li><strong><code>set_cell_color(p: Vector2i, color: Color) -&gt; void</code></strong>
    Assigns a solid <code>color</code> fill to the grid cell at position <code>p</code>.</li>
<li><strong><code>set_cells_color_bulk(cells: PackedVector2Array, color: Color) -&gt; void</code></strong>
    Applies a <code>color</code> fill to multiple cells efficiently.</li>
<li><strong><code>clear_all() -&gt; void</code></strong>
    Resets all grid cells to transparent, effectively clearing all fills, marks, strokes, and hatches.</li>
<li><strong><code>ensure_channel(name: String) -&gt; void</code></strong>
    Ensures a named numeric channel exists for heatmap data.</li>
<li><strong><code>set_channel_value(name: String, p: Vector2i, v: float) -&gt; void</code></strong>
    Writes a numeric <code>v</code> (value) to a named channel at position <code>p</code>. This data is used for heatmaps.</li>
<li><strong><code>apply_heatmap_auto(name: String, alpha: float = 0.8) -&gt; void</code></strong>
    Applies a heatmap visualization for the given channel <code>name</code>, automatically determining the min/max values from the channel's data.</li>
<li><strong><code>apply_heatmap(name: String, vmin: float, vmax: float, alpha: float = 0.8) -&gt; void</code></strong>
    Applies a heatmap visualization for the given channel <code>name</code>, mapping values between <code>vmin</code> and <code>vmax</code> to colors from the <code>heat_gradient</code>.</li>
<li><strong><code>apply_color_map(colors: Array) -&gt; void</code></strong>
    Applies a bulk color map (an array of <code>Color</code> objects) to the grid, typically generated by procedural world services.</li>
<li><strong><code>set_mark(p: Vector2i, mark_type: int, color: Color = Color(1, 1, 1, 1), size01: float = 1.0, rotation_rad: float = 0.0, thickness01: float = 0.5) -&gt; void</code></strong>
    Draws a specific <code>mark_type</code> (e.g., <code>DOT</code>, <code>CROSS</code>, <code>ARROW</code>) at position <code>p</code> with a given <code>color</code> and other visual properties.</li>
<li><strong><code>clear_mark(p: Vector2i) -&gt; void</code></strong>
    Removes any mark from the cell at <code>p</code>.</li>
<li><strong><code>set_stroke(p: Vector2i, color: Color = Color(1, 1, 1, 1), thickness01: float = 0.25, corner01: float = 0.0) -&gt; void</code></strong>
    Draws an outline (stroke) around the cell at <code>p</code> with a specified <code>color</code> and <code>thickness</code>.</li>
<li><strong><code>clear_stroke(p: Vector2i) -&gt; void</code></strong>
    Removes any stroke from the cell at <code>p</code>.</li>
<li><strong><code>set_hatch(p: Vector2i, pattern: int, color: Color, scale01: float = 0.5, angle01: float = 0.0, anim01: float = 0.0) -&gt; void</code></strong>
    Applies a hatch pattern (e.g., <code>CHECKER</code>, <code>DIAG</code>, <code>STRIPES</code>) to the cell at <code>p</code>.</li>
<li><strong><code>stroke_outline_for(tiles: PackedVector2Array, color: Color = Color(1, 1, 1, 0.9), thickness01: float = 0.15, corner01: float = 0.0) -&gt; void</code></strong>
    A convenience method to draw outlines around a collection of tiles, useful for highlighting paths or selected areas.</li>
<li><strong><code>set_world_offset(offset: Vector2) -&gt; void</code></strong>
    Sets the global offset for the renderer, useful for camera alignment.</li>
<li><strong><code>generate_ascii_field() -&gt; String</code></strong>
    Generates and returns a string representation of the current grid state, suitable for console output.</li>
<li><strong><code>set_ascii_entity(p: Vector2i, symbol: String, color: Color = Color(1, 1, 1, 1), priority: int = 0, id: int = -1, z_index: int = 0) -&gt; void</code></strong>
    Places an ASCII <code>symbol</code> at position <code>p</code>. Entities may stack, and are sorted by <code>priority</code> then <code>z_index</code>. <code>id</code> identifies the source actor for selective removal.</li>
<li><strong><code>clear_ascii_entities() -&gt; void</code></strong>
    Clears all ASCII entities from the grid.</li>
<li><strong><code>remove_ascii_actor(actor: Variant) -&gt; void</code></strong>
    Removes a specific actor's ASCII representation from the grid.</li>
<li><strong><code>collect_ascii_entities(actors: Array) -&gt; void</code></strong>
    Gathers ASCII entities from a list of actors, respecting their <code>size</code> and <code>get_ascii_z_index()</code> for multi-tile representation.</li>
<li><strong><code>update_input(pos: Vector2i, action: String) -&gt; void</code></strong>
    Simulates user input for headless tools, marking a grid location and recording the last interaction. Supported actions include <code>select</code>, <code>move</code>, <code>target</code>, <code>click</code>, <code>drag_start</code>, <code>drag</code>, <code>drag_end</code>, and <code>clear</code>.</li>
</ul>
<h2>Usage Example</h2>
<pre><code class="language-gdscript">var grid_vis := GridRealtimeRenderer.new()
add_child(grid_vis) # Add to the scene tree

# Set the grid size (important for initialization)
grid_vis.set_grid_size(32, 32)

# Direct colors: Highlight a specific cell in red
grid_vis.set_cell_color(Vector2i(1, 2), Color.RED)

# Heatmap: Visualize a &quot;danger&quot; channel
grid_vis.ensure_channel(&quot;danger&quot;) # Make sure the channel exists
for y in range(grid_vis.grid_size.y):
    for x in range(grid_vis.grid_size.x):
        # Simulate some danger value based on position
        var danger_value = float(x + y) / (grid_vis.grid_size.x + grid_vis.grid_size.y) * 100.0
        grid_vis.set_channel_value(&quot;danger&quot;, Vector2i(x, y), danger_value)

grid_vis.apply_heatmap(&quot;danger&quot;, 0.0, 100.0, 0.65) # Map values 0-100 to heatmap colors with 65% opacity

# Bulk color maps: Apply a map generated by a procedural world service
# Assuming 'colors' is an Array of Colors from a map generator
# grid_vis.apply_color_map(colors)
</code></pre>
<h2>GPU Labels</h2>
<p>For rendering text labels efficiently, especially many of them, enable <code>use_gpu_labels</code>. This batches text rendering, improving performance. Always wrap your label calls with <code>begin_labels()</code> and <code>end_labels()</code> to ensure all strings are drawn in a single optimized pass.</p>
<h3>Class: <code>GPULabelBatcher</code> (inherits from <code>Node2D</code>)</h3>
<p>The <code>GPULabelBatcher</code> is an internal component used by <code>GridRealtimeRenderer</code> when <code>use_gpu_labels</code> is enabled. You typically won't interact with it directly.</p>
<h4>Methods (used internally by <code>GridRealtimeRenderer</code>)</h4>
<ul>
<li><strong><code>begin() -&gt; void</code></strong>: Prepares the batcher for new labels.</li>
<li><strong><code>push(text: String, pos: Vector2, color: Color = Color(1, 1, 1, 1)) -&gt; void</code></strong>: Adds a single label to the batch.</li>
<li><strong><code>end() -&gt; void</code></strong>: Renders all batched labels.</li>
</ul>
<pre><code class="language-gdscript"># Ensure use_gpu_labels is true on your GridRealtimeRenderer instance
grid_vis.use_gpu_labels = true
grid_vis.label_font = preload(&quot;res://path/to/your_font.tres&quot;) # Set a font resource

grid_vis.begin_labels()
grid_vis.push_label(&quot;HQ&quot;, Vector2i(0,0).to_float() * grid_vis.cell_size, Color.WHITE) # Convert grid pos to world pos
grid_vis.push_label(&quot;Enemy&quot;, Vector2i(5,5).to_float() * grid_vis.cell_size, Color.RED)
grid_vis.end_labels()
</code></pre>
<h2>Vision Shaders</h2>
<p>The renderer supports different shader modes to apply global visual effects, such as night vision or fog of war.</p>
<ul>
<li><strong><code>set_shader_mode(mode: int) -&gt; void</code></strong>
    Switches the active shader mode. The integer <code>mode</code> corresponds to predefined visual effects.<ul>
<li><code>grid_vis.set_shader_mode(1)</code>: Activates a "night vision" effect.</li>
<li><code>grid_vis.set_shader_mode(2)</code>: Activates a "fog of war" effect.</li>
</ul>
</li>
</ul>
<h2>ASCII Debug Output</h2>
<p><code>GridRealtimeRenderer</code> can generate a lightweight ASCII snapshot of the grid, which is incredibly useful for headless tests, CI/CD pipelines, or inspecting game state in a terminal without a graphical display.</p>
<ul>
<li>The <code>ascii_update_sec</code> export controls how often the <code>ascii_debug</code> string refreshes.</li>
<li>Every interval, the renderer prints this string, enabling headless tests or external tools to inspect state.</li>
<li>The snapshot now mirrors the visual renderer more closely. Characters are assigned per cell using the same priority rules (glyph, stroke, fill, empty).</li>
<li>It can also include arbitrary actor symbols registered through <code>set_ascii_entity()</code>.</li>
<li>When <code>ascii_include_actors</code> is enabled, the renderer scans <code>ascii_actor_group</code> (default: "actors") every refresh and automatically inserts symbols for any nodes in that group.</li>
<li>Each actor can override <code>get_ascii_symbol()</code>, <code>get_ascii_color()</code>, <code>get_ascii_priority()</code>, and <code>get_ascii_z_index()</code> to customize its representation and layering in the ASCII output.</li>
<li>When <code>ascii_use_color</code> is enabled, the output uses ANSI color codes derived from the underlying cell color, allowing terminals to display the map with colored glyphs.</li>
</ul>
<h3>Default Layer Characters in ASCII Output:</h3>
<table>
<thead>
<tr>
<th>Char</th>
<th>Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>*</code></td>
<td>Glyph layer present</td>
</tr>
<tr>
<td><code>#</code></td>
<td>Outline/stroke present</td>
</tr>
<tr>
<td><code>+</code></td>
<td>Filled cell</td>
</tr>
<tr>
<td><code>.</code></td>
<td>Empty</td>
</tr>
</tbody>
</table>
<p>The helper <code>generate_ascii_field()</code> can be called to obtain the current snapshot on demand.</p>
<pre><code class="language-gdscript"># Example: Manually setting an ASCII entity
grid_vis.set_ascii_entity(Vector2i(1,0), &quot;@&quot;, Color.BLUE, 10, -1, 1)
</code></pre>
<p>The optional <code>priority</code> and <code>z_index</code> parameters determine which symbol appears when multiple entries stack in a single cell; entries sort by priority then z-index. <code>set_ascii_entity</code> silently ignores positions that fall outside the configured grid bounds so stray markers do not corrupt the snapshot.</p>
<p>When <code>collect_ascii_entities()</code> gathers actors, it now respects each actor's <code>size</code> property and optional <code>get_ascii_z_index()</code> method, stamping every cell in its footprint. This makes multi-tile creatures render correctly in the ASCII output.</p>
<p>Footprints are cached by actor so repeated calls avoid rebuilding the same offset list each frame. When an actor is removed, <code>remove_ascii_actor(actor)</code> can erase only its symbols without clearing the entire ASCII field. The renderer also tracks each actor's last position and size so <code>collect_ascii_entities()</code> only re-stamps cells for actors that moved or resized, keeping incremental updates efficient even with large casts.</p>
<h3>Interactive Input (Headless)</h3>
<p><code>GridRealtimeRenderer</code> exposes <code>update_input(pos, action)</code> to allow headless tools to simulate user interactions and mark grid locations.</p>
<ul>
<li><strong><code>update_input(pos: Vector2i, action: String) -&gt; void</code></strong>
    Records an interaction on the ASCII grid. Supported actions:<ul>
<li><code>"select"</code>: Highlights a cell and remembers its contents.</li>
<li><code>"move"</code>: Relocates the previously selected marker to a new cell.</li>
<li><code>"target"</code>: Marks a cell with <code>T</code> for targeting.</li>
<li><code>"click"</code>: Marks a cell with <code>C</code> for generic clicks.</li>
<li><code>"drag_start"</code>, <code>"drag"</code>, <code>"drag_end"</code>: Used to preview a path while dragging.</li>
<li><code>"clear"</code>: Removes all ASCII entities.</li>
</ul>
</li>
</ul>
<p>For example:</p>
<pre><code class="language-gdscript">grid_vis.update_input(Vector2i(2,1), &quot;select&quot;)
print(grid_vis.generate_ascii_field()) # This highlights the chosen cell with an 'X'.
</code></pre>
<p>After selecting, <code>move</code> will relocate the chosen marker, <code>target</code> paints a <code>T</code>, and <code>click</code> marks a <code>C</code>. Drag operations stream a cyan <code>o</code> along the path between the drag start and the current cursor location, allowing quick previews of potential routes. Begin a drag with <code>drag_start</code>, update it with <code>drag</code>, and finalize with <code>drag_end</code>. Paths remain until <code>clear</code> removes all markers or another drag begins.</p>
<p>Actors can also be polled automatically:</p>
<pre><code class="language-gdscript">var actor := BaseActor.new() # Assuming BaseActor is defined elsewhere
actor.grid_pos = Vector2i(1,0)
actor.add_to_group(&quot;actors&quot;) # Add to the group monitored by GridRealtimeRenderer
# GridRealtimeRenderer will pick up the actor on the next refresh if ascii_include_actors is true.
</code></pre>
<pre><code class="language-gdscript">var grid_vis := GridRealtimeRenderer.new()
grid_vis.grid_size = Vector2i(2,2)
grid_vis._ready() # Call _ready manually if not in scene tree
grid_vis.set_cell_color(Vector2i(0,0), Color.RED)
print(grid_vis.generate_ascii_field())
</code></pre>
<h2>Testing</h2>
<p><code>GridRealtimeRenderer</code> includes a self-test that verifies the ASCII snapshot and other core functionalities. Run all module tests headlessly with:</p>
<pre><code class="language-bash">godot4 --headless --path . --script scripts/test_runner.gd
</code></pre>
<p>This command ensures the renderer behaves as expected in a non-graphical environment, which is crucial for automated testing and continuous integration.</p>