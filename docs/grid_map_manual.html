<h1>LogicGridMap Manual</h1>
<p><code>grid/grid_map.gd</code> defines the <code>LogicGridMap</code> class, a pure data <code>Resource</code> describing the tactical board. It supports spatial queries, pathfinding, terrain tags, and area calculations without relying on visual nodes. This separation of concerns allows for headless operation (e.g., for server-side logic or automated testing) and flexible visual representations.</p>
<h2>Responsibilities</h2>
<ul>
<li>Track actor positions and occupancy on the grid.</li>
<li>Provide methods for movement validation and execution through <code>move_actor()</code> and <code>remove_actor()</code>.</li>
<li>Compute distances, line of sight (LOS), and pathfinding routes.</li>
<li>Calculate various area-of-effect (AoE) shapes.</li>
<li>Manage zones of control and flanking detection.</li>
<li>Store per-tile metadata such as movement costs, height levels, terrain tags, and cover information.</li>
<li>Support optional directional obstacles and diagonal movement rules for richer tactical constraints.</li>
</ul>
<h2>Core Concepts and API Details</h2>
<p>The <code>LogicGridMap</code> is the authoritative source for all spatial information in the game. It's designed to be a robust and efficient data structure for tactical gameplay.</p>
<h3>Class: <code>LogicGridMap</code> (inherits from <code>Resource</code>)</h3>
<p>As a <code>Resource</code>, <code>LogicGridMap</code> can be saved and loaded independently of scenes, making it highly reusable and persistent.</p>
<h4>Members</h4>
<ul>
<li><strong><code>map</code></strong> (<code>Grid</code>, Default: <code>new()</code>): This is the internal representation of the grid itself, likely a 2D array or similar structure that stores tile data.</li>
<li><strong><code>event_log</code></strong> (<code>Array</code>, Default: <code>[]</code>): An internal log for recording events related to grid operations, useful for debugging.</li>
</ul>
<h4>Methods</h4>
<h3>Actor Placement</h3>
<ul>
<li><strong><code>has_actor_at(pos: Vector2i) -&gt; bool</code></strong>
    Checks if there is any actor present at the specified grid position.<ul>
<li><code>pos</code>: The <code>Vector2i</code> coordinates to check.</li>
<li><strong>Returns:</strong> <code>true</code> if an actor occupies the tile, <code>false</code> otherwise.</li>
</ul>
</li>
<li><strong><code>get_actor_at(pos: Vector2i) -&gt; Variant</code></strong>
    Retrieves the actor object located at the specified grid position.<ul>
<li><code>pos</code>: The <code>Vector2i</code> coordinates to query.</li>
<li><strong>Returns:</strong> The <code>Object</code> representing the actor at <code>pos</code>, or <code>null</code> if no actor is found.</li>
</ul>
</li>
<li><strong><code>move_actor(actor: Object, from_pos: Vector2i, to_pos: Vector2i) -&gt; bool</code></strong>
    Handles the movement of an <code>actor</code> from <code>from_pos</code> to <code>to_pos</code>. This method validates multi-tile footprints and updates the internal <code>occupied</code> and <code>actor_positions</code> dictionaries.<ul>
<li><code>actor</code>: The actor object to move.</li>
<li><code>from_pos</code>: The actor's current position.</li>
<li><code>to_pos</code>: The target position.</li>
<li><strong>Returns:</strong> <code>true</code> if the move was successful, <code>false</code> otherwise.</li>
</ul>
</li>
<li><strong><code>remove_actor(actor: Object) -&gt; void</code></strong>
    Clears an actor's entries from the map, effectively removing it from the grid's tracking.<ul>
<li><code>actor</code>: The actor object to remove.</li>
</ul>
</li>
<li><strong><code>get_occupied_tiles(actor: Object) -&gt; Array[Vector2i]</code></strong>
    Returns an array of all <code>Vector2i</code> tiles that a given <code>actor</code> currently occupies, considering its size and footprint.</li>
</ul>
<h3>Spatial Queries</h3>
<ul>
<li><strong><code>is_in_bounds(pos: Vector2i) -&gt; bool</code></strong>
    Checks if a given <code>Vector2i</code> position is within the defined boundaries of the grid map.</li>
<li><strong><code>is_occupied(pos: Vector2i) -&gt; bool</code></strong>
    Checks if a specific tile at <code>pos</code> is currently occupied by any actor.</li>
<li><strong>Distance Helpers:</strong><ul>
<li><code>get_distance(from: Vector2i, to: Vector2i) -&gt; int</code>: Calculates the Manhattan distance (taxicab geometry) between two points.</li>
<li><code>get_chebyshev_distance(from: Vector2i, to: Vector2i) -&gt; int</code>: Calculates the Chebyshev distance (chessboard distance) between two points, useful for square-radius checks.</li>
</ul>
</li>
<li><strong><code>has_line_of_sight(a: Vector2i, b: Vector2i) -&gt; bool</code></strong>
    Determines if there is an unobstructed line of sight between two points <code>a</code> and <code>b</code> on the grid. This method typically uses Bresenham's algorithm and considers any defined LOS blockers or cover elements on the map.</li>
</ul>
<h3>Range Queries</h3>
<ul>
<li><strong><code>get_actors_in_radius(center: Vector2i, radius: int) -&gt; Array[Object]</code></strong>
    Returns an array of actor objects located within a specified <code>radius</code> around a <code>center</code> point, often using Chebyshev distance.</li>
<li><strong><code>get_positions_in_range(center: Vector2i, radius: int) -&gt; Array[Vector2i]</code></strong>
    Returns an array of <code>Vector2i</code> positions that are within a specified <code>radius</code> around a <code>center</code> point.</li>
</ul>
<h3>Pathfinding</h3>
<ul>
<li><strong><code>find_path(start: Vector2i, facing: Vector2i, goal: Vector2i, size: Vector2i) -&gt; Array[Vector2i]</code></strong>
    Implements the A* pathfinding algorithm to find the shortest path between a <code>start</code> and <code>goal</code> position. It considers movement costs, turning penalties (<code>TURN_COST</code> constant), climb restrictions, and supports multi-tile actors.</li>
<li><strong><code>find_path_for_actor(actor: Object, start: Vector2i, goal: Vector2i) -&gt; Array[Vector2i]</code></strong>
    A convenience wrapper around <code>find_path</code> that automatically uses the <code>actor</code>'s size and facing for path calculation.</li>
<li><strong><code>set_diagonal_movement(enable: bool) -&gt; void</code></strong>
    Toggles whether diagonal movements are considered valid during pathfinding and other spatial calculations.</li>
<li><strong><code>place_obstacle(pos: Vector2i, orientation: int) -&gt; void</code></strong>
    Inserts directional obstacles (e.g., walls) at a given position that block movement in a specific <code>orientation</code>.</li>
</ul>
<h3>Area of Effect (AoE)</h3>
<ul>
<li><strong><code>get_aoe_tiles(shape: String, origin: Vector2i, direction: Vector2i, range: int) -&gt; Array[Vector2i]</code></strong>
    Dispatches to internal helpers to calculate and return an array of <code>Vector2i</code> tiles covered by various AoE shapes, such as <code>burst</code>, <code>cone</code>, <code>line</code>, and <code>wall</code>.</li>
</ul>
<h3>Tactical Logic</h3>
<ul>
<li><strong><code>get_zone_of_control(actor: Object, radius: int, arc: float) -&gt; Array[Vector2i]</code></strong>
    Calculates and returns an array of "threatened tiles" around an <code>actor</code>, representing its zone of control or influence.</li>
<li><strong><code>get_cover(pos: Vector2i) -&gt; Dictionary</code></strong>
    Retrieves cover information for a specific tile.</li>
<li><strong><code>set_cover(pos: Vector2i, type: int, direction: Vector2i, height: int) -&gt; void</code></strong>
    Sets directional cover information for a tile, including type, direction, and optional height.</li>
<li><strong>Utility Functions:</strong> Provides internal utility functions to determine flanking status, retrieve tile tags, query height levels, and calculate per-tile movement costs.</li>
</ul>
<h2>Integration Notes</h2>
<ul>
<li><strong>Resource-Based:</strong> Because <code>LogicGridMap</code> is a <code>Resource</code>, it can be saved and loaded independently of scenes. This makes it ideal for persistent world data or for generating maps dynamically and then saving them.</li>
<li><strong>Pairing with Visuals:</strong> <code>LogicGridMap</code> is purely data. To visualize the grid and its contents, you will typically pair it with a rendering module like <code>GridVisualLogic</code> (for simple debugging) or <code>GridRealtimeRenderer</code> (for high-performance visual overlays).</li>
<li><strong>Gameplay System Integration:</strong> It forms the backbone for gameplay systems such as <code>TurnBasedGridTimespace</code> (for movement validation and actor placement) and <code>GridInteractor</code> (for translating user input into grid selections).</li>
<li><strong>Debugging with <code>event_log</code>:</strong> Use the internal <code>event_log</code> array to record operations when debugging complex movement or spatial query bugs.</li>
</ul>
<h2>Testing</h2>
<p>While <code>LogicGridMap</code> currently lacks a dedicated <code>run_tests()</code> method, it is exercised extensively by the tests for <code>turn_timespace.gd</code> and other modules that rely on its spatial capabilities. When adding new features or modifying existing ones, it is highly recommended to implement a <code>run_tests()</code> method similar to other modules to ensure deterministic behavior and prevent regressions.</p>