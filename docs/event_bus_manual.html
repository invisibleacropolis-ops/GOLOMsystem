<h1>EventBus Module Manual</h1>
<p>The <code>event_bus.gd</code> module provides a lightweight, append-only log of game events. Other systems push structured dictionaries here so analytics, replays, or debuggers can consume them later.</p>
<h2>Responsibilities</h2>
<ul>
<li>Maintain the <code>entries</code> array of event dictionaries.</li>
<li>Offer methods to append events, serialize the log, and replay events for deterministic testing or analysis.</li>
</ul>
<h2>Core Concepts and API Details</h2>
<p>The <code>EventBus</code> module is a foundational component for maintaining a clear, chronological record of everything that happens in the game. This "single source of truth" for events is invaluable for debugging complex interactions, performing game analytics, and enabling deterministic replays.</p>
<h3>Class: <code>EventBus</code> (inherits from <code>Node</code>)</h3>
<p>This is the main class for managing the event log. As a <code>Node</code>, it can be easily integrated into your game's scene tree, typically as a singleton or part of a <code>RuntimeServices</code> aggregation.</p>
<h4>Members</h4>
<ul>
<li><strong><code>entries</code></strong> (<code>Array</code>, Default: <code>[]</code>): This array stores all the event dictionaries pushed to the <code>EventBus</code>. Each element in this array represents a single game event, recorded in the order it occurred. This array is the core data structure of the event log.</li>
</ul>
<h4>Methods</h4>
<ul>
<li><strong><code>push(evt: Dictionary) -&gt; void</code></strong>
    Appends a new event dictionary to the <code>entries</code> array. This is the primary method used by other modules to record game events.<ul>
<li><code>evt</code>: A <code>Dictionary</code> representing the event. It's highly recommended that this dictionary includes a <code>t</code> (type) field to categorize the event (e.g., <code>{"t": "round_start"}</code>, <code>{"t": "damage_dealt"}</code>). Additional keys can be added to provide context specific to the event.</li>
</ul>
</li>
<li><strong><code>serialize() -&gt; String</code></strong>
    Converts the entire <code>entries</code> array into a JSON-formatted string. This string can then be saved to a file, sent over a network, or stored in a database, allowing for persistence of the game's event history.<ul>
<li><strong>Returns:</strong> A <code>String</code> containing the JSON representation of the event log.</li>
</ul>
</li>
<li><strong><code>replay(json: String, handler: Callable) -&gt; void</code></strong>
    Replays a sequence of events from a serialized JSON string. This method is crucial for deterministic testing, debugging, and potentially for features like "rewind" or "spectator mode."<ul>
<li><code>json</code>: A <code>String</code> containing the JSON-formatted event log (typically obtained from <code>serialize()</code>).</li>
<li><code>handler</code>: A <code>Callable</code> (e.g., a function or method) that will be invoked for each event in the replayed log. This allows external systems to react to the replayed events without directly modifying the game state during replay.</li>
</ul>
</li>
</ul>
<h4>Signals</h4>
<p>The <code>EventBus</code> itself does not emit signals, as its primary role is to be a passive, append-only log. Other modules that push events to the <code>EventBus</code> might emit their own signals.</p>
<h2>Usage</h2>
<pre><code class="language-gdscript">var bus := EventBus.new()

# Example 1: Pushing a simple event
bus.push({&quot;t&quot;: &quot;round_start&quot;, &quot;round&quot;: 1, &quot;timestamp&quot;: OS.get_unix_time()})

# Example 2: Pushing an event with more details
var actor_id = &quot;player_1&quot;
var ability_id = &quot;fireball&quot;
var target_pos = Vector2i(5, 3)
bus.push({
    &quot;t&quot;: &quot;ability_executed&quot;,
    &quot;actor_id&quot;: actor_id,
    &quot;ability&quot;: ability_id,
    &quot;target_position&quot;: target_pos,
    &quot;damage_dealt&quot;: 25
})

# Serialize the log for saving or debugging
var json_log := bus.serialize()
print(&quot;Serialized Event Log: &quot; + json_log)

# Define a handler function for replaying events
func _on_event_replayed(event_data: Dictionary):
    print(&quot;Replayed Event: &quot; + str(event_data))
    if event_data.has(&quot;t&quot;):
        match event_data[&quot;t&quot;]:
            &quot;round_start&quot;:
                print(&quot;  -&gt; Round &quot; + str(event_data.get(&quot;round&quot;, &quot;N/A&quot;)) + &quot; started.&quot;)
            &quot;ability_executed&quot;:
                print(&quot;  -&gt; Actor &quot; + event_data.get(&quot;actor_id&quot;, &quot;N/A&quot;) + &quot; used &quot; + event_data.get(&quot;ability&quot;, &quot;N/A&quot;) + &quot;.&quot;)

# Replay the log using the handler
bus.replay(json_log, Callable(self, &quot;_on_event_replayed&quot;))
</code></pre>
<h2>Integration Notes</h2>
<ul>
<li><strong>Standardized Event Structure:</strong> To maximize the utility of the <code>EventBus</code> for tooling and analysis, it's crucial to standardize the structure of event dictionaries. Always include a <code>t</code> field (for "type") to categorize the event. Additional keys can be added to provide context specific to the event. For example, all "damage_dealt" events should consistently use keys like <code>attacker_id</code>, <code>defender_id</code>, and <code>amount</code>.</li>
<li><strong>Deterministic Replays:</strong> The <code>EventBus</code> is a cornerstone for deterministic replays. To achieve this, ensure that all non-random, state-changing operations are recorded as events. When replaying, you would typically disable direct game logic execution and instead drive the game state solely by processing events from the log. This is particularly useful for debugging hard-to-reproduce bugs or for competitive game analysis.</li>
<li><strong>Non-Mutating Replay Handler:</strong> The <code>replay()</code> method accepts a <code>Callable</code> handler. This design allows tests or analytics tools to process events during replay without directly mutating the game's live state. This separation is vital for maintaining the integrity of the replay process.</li>
<li><strong>Performance Considerations:</strong> While append-only, for very long game sessions, the <code>entries</code> array can grow large. Consider strategies for periodically serializing and clearing the log, or implementing a circular buffer if only recent history is needed.</li>
</ul>
<h2>Testing</h2>
<p>Run the shared test runner to verify the <code>EventBus</code> module's functionality:</p>
<pre><code class="language-bash">godot4 --headless --path . --script scripts/test_runner.gd -- --module=event_bus
</code></pre>
<p>This test ensures that the module correctly records a dummy entry, can serialize it, and can successfully replay it using a provided handler, confirming its core responsibilities are met.</p>