<h1>Attributes Module Manual</h1>
<p><code>attributes.gd</code> centralizes all numeric statistics for actors. By funnelling reads through a single service, formulas remain consistent and easy to audit. The module now supports percentage modifiers and clamped ranges to keep values within defined bounds.</p>
<h2>Responsibilities</h2>
<ul>
<li>Store base values per actor/key pair.</li>
<li>Apply additive, multiplicative, and percentage modifiers with optional sources and durations.</li>
<li>Provide <code>get_value()</code> to query the final stat after all modifiers and ranges.</li>
<li>Record operations in <code>event_log</code> for debugging.</li>
</ul>
<h2>Core Concepts and API Details</h2>
<p>The <code>Attributes</code> module is designed to manage all numerical statistics (attributes) for game entities (actors). This centralized approach ensures consistency and simplifies debugging by providing a single source of truth for all attribute calculations.</p>
<h3>Class: <code>Attributes</code> (inherits from <code>Node</code>)</h3>
<p>This is the main class for managing attributes. It's a <code>Node</code>, meaning it can be integrated into your game scene tree.</p>
<h4>Members</h4>
<ul>
<li><strong><code>base_values</code></strong> (<code>Dictionary</code>, Default: <code>{}</code>): This dictionary stores the fundamental, unmodified values for each attribute, keyed by actor and then by attribute name (e.g., <code>base_values[actor_id]["HLTH"] = 100</code>). These are the starting points before any modifiers are applied.</li>
<li><strong><code>modifiers</code></strong> (<code>Dictionary</code>, Default: <code>{}</code>): This complex dictionary holds all active modifiers. Modifiers can be temporary (e.g., from buffs, debuffs, equipment) and are applied on top of <code>base_values</code>. They are typically structured to allow for additive, multiplicative, and percentage-based changes.</li>
<li><strong><code>ranges</code></strong> (<code>Dictionary</code>, Default: <code>{}</code>): This dictionary defines the minimum and maximum allowed values for specific attributes. When <code>get_value()</code> is called, the final calculated value is clamped within these defined ranges.</li>
<li><strong><code>event_log</code></strong> (<code>Array</code>, Default: <code>[]</code>): An array that records significant events related to attribute changes, such as a base value being set or a modifier being added/removed. This log is useful for debugging and analysis.</li>
</ul>
<h4>Methods</h4>
<ul>
<li><strong><code>log_event(t: String, actor: Object = null, pos: Variant = null, data: Variant = null) -&gt; void</code></strong>
    Records a structured event into the <code>event_log</code>. This is a general-purpose logging method used internally by the module to track attribute-related occurrences.</li>
<li><strong><code>set_base(actor: Object, key: String, value: float) -&gt; void</code></strong>
    Sets the fundamental, unmodified <code>value</code> for a specific <code>key</code> (attribute name) for a given <code>actor</code>. This is the starting point for all calculations.<ul>
<li><code>actor</code>: The game object whose attribute is being set.</li>
<li><code>key</code>: The name of the attribute (e.g., "HLTH", "STR", "DEX").</li>
<li><code>value</code>: The base numerical value for the attribute.</li>
</ul>
</li>
<li><strong><code>add_modifier(actor: Object, key: String, add: float = 0.0, mul: float = 1.0, source: String = "", duration: int = 0, perc: float = 0.0) -&gt; void</code></strong>
    Adds a new modifier entry to an actor's attribute. Modifiers are applied in a specific order: <code>add</code> (additive) first, then <code>mul</code> (multiplicative), and finally <code>perc</code> (percentage).<ul>
<li><code>actor</code>: The game object affected by the modifier.</li>
<li><code>key</code>: The attribute being modified.</li>
<li><code>add</code>: An additive bonus (e.g., +5 HP).</li>
<li><code>mul</code>: A multiplicative factor (e.g., 1.2 for +20% damage).</li>
<li><code>source</code>: A string identifying the origin of the modifier (e.g., "buff", "equipment_sword", "poison_status"). This is crucial for <code>clear_modifiers</code>.</li>
<li><code>duration</code>: How many turns/ticks the modifier lasts (0 for permanent).</li>
<li><code>perc</code>: A percentage bonus (e.g., 0.1 for +10% of base value).</li>
</ul>
</li>
<li><strong><code>clear_modifiers(actor: Object, source: String) -&gt; void</code></strong>
    Removes all modifiers that originated from a specific <code>source</code> for a given <code>actor</code>. This is essential for removing temporary effects like buffs or debuffs.<ul>
<li><code>actor</code>: The game object whose modifiers are being cleared.</li>
<li><code>source</code>: The identifier of the modifiers to remove.</li>
</ul>
</li>
<li><strong><code>get_value(actor: Object, key: String) -&gt; float</code></strong>
    Computes and returns the final, effective value of an attribute for a given <code>actor</code> and <code>key</code>. This method takes into account the base value, all active modifiers, and then clamps the result within any defined ranges. <strong>Always use this method to query an actor's stats.</strong><ul>
<li><code>actor</code>: The game object whose attribute value is being queried.</li>
<li><code>key</code>: The name of the attribute.</li>
<li><strong>Returns:</strong> The calculated final attribute value (float).</li>
</ul>
</li>
<li><strong><code>set_range(key: String, min_value: float, max_value: float) -&gt; void</code></strong>
    Defines a clamped numerical range for a specific attribute <code>key</code>. Any value calculated for this attribute will not go below <code>min_value</code> or above <code>max_value</code>.<ul>
<li><code>key</code>: The attribute name for which to define the range.</li>
<li><code>min_value</code>: The minimum allowed value.</li>
<li><code>max_value</code>: The maximum allowed value.</li>
</ul>
</li>
<li><strong><code>run_tests() -&gt; Dictionary</code></strong>
    Executes internal self-tests for the <code>Attributes</code> module, returning a dictionary of test results. Useful for continuous integration and development.</li>
</ul>
<h2>Usage Pattern</h2>
<pre><code class="language-gdscript">var attrs := Attributes.new()

# Define base health for 'hero' actor
attrs.set_base(hero, &quot;HLTH&quot;, 50.0) # Base health is 50

# Define a clamped range for &quot;HLTH&quot; between 0 and 100
attrs.set_range(&quot;HLTH&quot;, 0.0, 100.0)

# Add a temporary buff that adds 25 to HLTH from source &quot;buff&quot;
attrs.add_modifier(hero, &quot;HLTH&quot;, 25.0, 1.0, &quot;buff&quot;, 5) # Lasts 5 turns

# Add a permanent percentage buff that adds 50% of base HLTH from source &quot;permanent_buff&quot;
attrs.add_modifier(hero, &quot;HLTH&quot;, 0.0, 1.0, &quot;permanent_buff&quot;, 0, 0.5)

# Calculate current health:
# Base (50) + Additive (25) + Percentage (50% of 50 = 25) = 100
var total_health := attrs.get_value(hero, &quot;HLTH&quot;) # Result: 100 (clamped by range)

print(&quot;Hero's current health: &quot; + str(total_health))

# After some turns, clear the &quot;buff&quot; modifier
# (Note: higher-level systems like Statuses would typically manage this duration)
# attrs.clear_modifiers(hero, &quot;buff&quot;)
# total_health = attrs.get_value(hero, &quot;HLTH&quot;) # Now: Base (50) + Percentage (25) = 75
</code></pre>
<h2>Integration Notes</h2>
<ul>
<li><strong>Centralized Queries:</strong> It is critical to <strong>always query an actor's statistics via <code>get_value()</code></strong>. Do not attempt to read actor fields directly, as this bypasses the modifier and clamping logic, leading to inconsistent and incorrect values.</li>
<li><strong>Duration Management:</strong> The <code>duration</code> parameter in <code>add_modifier</code> is stored by the <code>Attributes</code> module but <strong>not automatically decremented</strong>. Higher-level systems, such as the <code>Statuses</code> module, are responsible for tracking the passage of time and calling <code>clear_modifiers</code> when a temporary effect expires. This separation of concerns keeps the <code>Attributes</code> module focused solely on calculation.</li>
<li><strong>State Persistence:</strong> To save and load an actor's complete attribute state (for game saving/loading), you must persist the contents of the <code>base_values</code> and <code>modifiers</code> dictionaries. The <code>ranges</code> are typically static definitions and might not need to be saved per actor.</li>
</ul>
<h2>Testing</h2>
<p>Run the module's built-in test to verify its functionality:</p>
<pre><code class="language-bash">godot4 --headless --path . --script scripts/test_runner.gd -- --module=attributes
</code></pre>
<p>The test suite specifically checks scenarios like health clamping (e.g., health not exceeding 100 even after additive and percentage bonuses), ensuring the core calculation and range enforcement mechanisms of the <code>Attributes</code> module function as expected.</p>