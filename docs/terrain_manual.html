<h1>Terrain Module Manual</h1>
<p><code>terrain.gd</code> defines the <code>Terrain</code> module, which centralizes terrain type definitions used by <code>LogicGridMap</code>. It loads a default set of terrain rules from <code>data/terrain.json</code> and allows runtime modification or registration of new types. This service can apply terrain properties to tiles on a <code>LogicGridMap</code>, dynamically updating movement costs, line-of-sight (LOS) blockers, and tag arrays in real time.</p>
<h2>Responsibilities</h2>
<ul>
<li>Load and store a catalog of terrain definitions.</li>
<li>Provide helpers to register new terrain types and mutate existing ones.</li>
<li>Apply terrain data to map tiles, synchronizing tags, movement cost and
    LOS blockers.</li>
<li>Query terrain IDs by tag for grouping or procedural generation.</li>
</ul>
<h2>Core Concepts and API Details</h2>
<p>The <code>Terrain</code> module acts as a registry for all terrain types in the game. By centralizing terrain definitions, it ensures consistency across the game world and allows for easy modification and extension of terrain properties.</p>
<h3>Class: <code>Terrain</code> (inherits from <code>Node</code>)</h3>
<p>As a <code>Node</code>, <code>Terrain</code> can be integrated into your game's scene tree, often as part of a <code>RuntimeServices</code> aggregation.</p>
<h4>Members</h4>
<ul>
<li><strong><code>definitions</code></strong> (<code>Dictionary</code>, Default: <code>{}</code>): This dictionary stores all loaded and registered terrain definitions, keyed by their unique string ID. Each value is a dictionary containing the properties of that terrain type.</li>
<li><strong><code>event_log</code></strong> (<code>Array</code>, Default: <code>[]</code>): An internal log for recording events related to terrain changes, useful for debugging.</li>
</ul>
<h4>Methods</h4>
<ul>
<li><strong><code>log_event(t: String, actor: Object = null, pos: Variant = null, data: Variant = null) -&gt; void</code></strong>
    Records structured events for debugging and tests. This is a general-purpose logging method used internally.</li>
<li><strong><code>load_from_file(path: String) -&gt; void</code></strong>
    Replaces the current set of terrain definitions with those loaded from a JSON file at the specified <code>path</code>. This is typically used to load the initial terrain data.<ul>
<li><code>path</code>: The file path to the JSON file containing terrain definitions.</li>
</ul>
</li>
<li><strong><code>register_type(id: String, data: Dictionary) -&gt; void</code></strong>
    Adds a new terrain definition or overrides an existing one. This allows for dynamic creation or modification of terrain types at runtime.<ul>
<li><code>id</code>: The unique string ID for the terrain type (e.g., "forest", "swamp").</li>
<li><code>data</code>: A <code>Dictionary</code> containing the properties of the terrain type (e.g., <code>{"move_cost": 2, "blocks_vision": false, "tags": ["natural", "forest"]}</code>).</li>
</ul>
</li>
<li><strong><code>get_type(id: String) -&gt; Dictionary</code></strong>
    Fetches a specific terrain definition by its ID.<ul>
<li><code>id</code>: The unique string ID of the terrain type.</li>
<li><strong>Returns:</strong> A <code>Dictionary</code> containing the terrain properties, or <code>null</code> if not found.</li>
</ul>
</li>
<li><strong><code>set_property(id: String, key: String, value: Variant) -&gt; void</code></strong>
    Mutates a single property of an existing terrain definition. This is useful for dynamic changes to terrain behavior (e.g., making a "water" tile temporarily walkable).<ul>
<li><code>id</code>: The ID of the terrain type to modify.</li>
<li><code>key</code>: The name of the property to change (e.g., "move_cost", "blocks_vision").</li>
<li><code>value</code>: The new value for the property.</li>
</ul>
</li>
<li><strong><code>get_with_tag(tag: String) -&gt; Array[String]</code></strong>
    Returns an array of terrain IDs that include a specific <code>tag</code>. This is useful for querying terrain types based on shared characteristics.<ul>
<li><code>tag</code>: The tag to search for (e.g., "walkable", "liquid").</li>
<li><strong>Returns:</strong> An <code>Array</code> of <code>String</code>s, where each string is a terrain ID.</li>
</ul>
</li>
<li><strong><code>apply_to_map(map: LogicGridMap, pos: Vector2i, id: String) -&gt; void</code></strong>
    Applies the properties of a specified terrain type (<code>id</code>) to a tile at <code>pos</code> on a <code>LogicGridMap</code>. This method updates the <code>LogicGridMap</code>'s internal data, synchronizing properties like movement cost, LOS blockers, and tags.<ul>
<li><code>map</code>: The <code>LogicGridMap</code> instance to modify.</li>
<li><code>pos</code>: The <code>Vector2i</code> coordinates of the tile to update.</li>
<li><code>id</code>: The ID of the terrain type to apply.</li>
</ul>
</li>
<li><strong><code>run_tests() -&gt; Dictionary</code></strong>
    Executes internal self-tests for the <code>Terrain</code> module, returning a dictionary of test results.</li>
</ul>
<h2>Default Terrain Types</h2>
<p>The default terrain types are defined in <code>data/terrain.json</code>. These include:</p>
<ul>
<li><code>grass</code></li>
<li><code>dirt</code></li>
<li><code>stone</code></li>
<li><code>wood_floor</code></li>
<li><code>stone_floor</code></li>
<li><code>water</code></li>
<li><code>paved</code></li>
<li><code>road</code></li>
</ul>
<p>Each terrain type typically includes properties like <code>move_cost</code> (how many AP it costs to move onto), <code>is_walkable</code>, <code>is_buildable</code>, <code>is_flammable</code>, <code>is_liquid</code>, <code>blocks_vision</code> (for LOS calculations), and custom <code>tags</code> (e.g., "natural", "urban").</p>
<h2>Usage Example</h2>
<pre><code class="language-gdscript">var terrain_service := Terrain.new()
add_child(terrain_service) # Add to scene tree if not part of RuntimeServices

# Load default terrain definitions from file
terrain_service.load_from_file(&quot;res://data/terrain.json&quot;)

# Register a new custom terrain type at runtime
terrain_service.register_type(&quot;lava&quot;, {
    &quot;move_cost&quot;: 5,
    &quot;is_walkable&quot;: false,
    &quot;is_flammable&quot;: true,
    &quot;blocks_vision&quot;: false,
    &quot;tags&quot;: [&quot;hazard&quot;, &quot;hot&quot;]
})

# Mutate a property of an existing terrain type
terrain_service.set_property(&quot;water&quot;, &quot;move_cost&quot;, 3) # Make water more difficult to traverse

# Get terrain IDs that are &quot;walkable&quot;
var walkable_terrains = terrain_service.get_with_tag(&quot;walkable&quot;)
print(&quot;Walkable terrains: &quot; + str(walkable_terrains))

# Apply a terrain type to a tile on your LogicGridMap
var my_logic_grid_map := LogicGridMap.new() # Assuming you have a LogicGridMap instance
my_logic_grid_map.width = 10
my_logic_grid_map.height = 10
terrain_service.apply_to_map(my_logic_grid_map, Vector2i(5, 5), &quot;lava&quot;)
print(&quot;Tile at (5,5) is now lava.&quot;)
</code></pre>
<h2>Integration Notes</h2>
<ul>
<li><strong>Synchronization with <code>LogicGridMap</code>:</strong> The <code>apply_to_map()</code> method is crucial for synchronizing terrain properties with the <code>LogicGridMap</code>. When you change a terrain type on a tile, this method ensures that the <code>LogicGridMap</code>'s internal data (movement costs, LOS blockers, tags) is updated accordingly.</li>
<li><strong>Data-Driven Design:</strong> By defining terrain types in a JSON file, designers can easily modify and add new terrain behaviors without requiring code changes.</li>
<li><strong>Dynamic World:</strong> The <code>register_type()</code> and <code>set_property()</code> methods allow for dynamic changes to the game world, enabling events like floods, fires, or magical transformations that alter terrain properties.</li>
</ul>
<h2>Testing</h2>
<p>The <code>run_tests()</code> method verifies applying terrain to a map, updating a property at runtime, and filtering by tags. You can execute these tests via the shared runner:</p>
<pre><code class="language-bash">godot4 --headless --path . --script scripts/test_runner.gd -- --module=terrain
</code></pre>
<p>This ensures the <code>Terrain</code> module functions correctly and consistently applies its definitions to the game's logical grid.</p>