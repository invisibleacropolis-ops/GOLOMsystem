<h1>GridVisualLogic Module Manual</h1>
<p><code>GridVisualLogic</code> is a <code>Node2D</code> that renders a rectangular grid using Godot's immediate drawing API (<code>_draw()</code> method). It serves as the visual companion to <code>LogicGridMap</code> by painting each tile according to a supplied state. This module is primarily intended for debugging, visualizing game state, or powering a minimal, lightweight UI.</p>
<h2>Features</h2>
<ul>
<li>Configurable grid dimensions (<code>grid_size</code>) and individual <code>cell_size</code>.</li>
<li>Optional connection to a <code>LogicGridMap</code> resource to automatically adopt its width and height, ensuring visual and logical grids are synchronized.</li>
<li>Per-cell state dictionary (<code>cell_states</code>) accepting either:<ul>
<li>A <code>Color</code> to fill the tile, allowing for simple color-coding of grid cells.</li>
<li>A <code>Callable</code> that receives <code>(self, Rect2)</code> to perform custom drawing operations (e.g., drawing circles, lines, or textures) within the cell's bounds.</li>
</ul>
</li>
<li>Lightweight <code>run_tests()</code> helper verifying basic state management.</li>
<li>Batch <code>update_cells(states)</code> helper for efficiently applying many tile changes at once.</li>
</ul>
<h2>Core Concepts and API Details</h2>
<p>The <code>GridVisualLogic</code> module provides a flexible way to visually represent the underlying game grid. It's important to remember that this module is purely for visualization; it does not manage game state or logic itself.</p>
<h3>Class: <code>GridVisualLogic</code> (inherits from <code>Node2D</code>)</h3>
<p>As a <code>Node2D</code>, <code>GridVisualLogic</code> can be added to your scene tree and positioned like any other 2D node. Its drawing operations occur within its local coordinate space.</p>
<h4>Members</h4>
<ul>
<li><strong><code>cell_size</code></strong> (<code>int</code>, Default: <code>32</code>): The pixel dimensions (width and height) of each individual grid cell.</li>
<li><strong><code>grid_size</code></strong> (<code>Vector2i</code>, Default: <code>Vector2i(8, 8)</code>): A <code>Vector2i</code> representing the number of tiles in the X and Y dimensions of the grid. This is automatically updated when a <code>LogicGridMap</code> is assigned.</li>
<li><strong><code>grid_map</code></strong> (<code>LogicGridMap</code>, Default: <code>null</code>): A reference to an instance of <code>LogicGridMap</code>. When set, <code>GridVisualLogic</code> will automatically adjust its <code>grid_size</code> to match the dimensions of the <code>LogicGridMap</code>.</li>
<li><strong><code>cell_states</code></strong> (<code>Dictionary</code>, Default: <code>{}</code>): This dictionary stores the custom state for each cell. Keys are <code>Vector2i</code> positions, and values are either <code>Color</code> objects or <code>Callable</code> functions.</li>
<li><strong><code>event_log</code></strong> (<code>Array</code>, Default: <code>[]</code>): An internal log for recording events related to visual logic, useful for debugging.</li>
</ul>
<h4>Methods</h4>
<ul>
<li><strong><code>set_grid_map(map: LogicGridMap) -&gt; void</code></strong>
    Assigns a <code>LogicGridMap</code> instance to the visualizer. When a map is assigned, <code>GridVisualLogic</code> automatically adopts its dimensions (<code>width</code> and <code>height</code>) for its own <code>grid_size</code>. This ensures that the visual representation matches the logical grid.<ul>
<li><code>map</code>: The <code>LogicGridMap</code> instance to associate with this visualizer.</li>
</ul>
</li>
<li><strong><code>set_grid_size(width: int, height: int) -&gt; void</code></strong>
    Manually specifies the width and height of the grid in tiles. This method can be used if you don't have a <code>LogicGridMap</code> or want to override its dimensions.<ul>
<li><code>width</code>: The desired width of the grid in tiles.</li>
<li><code>height</code>: The desired height of the grid in tiles.</li>
</ul>
</li>
<li><strong><code>set_cell_state(pos: Vector2i, state: Variant) -&gt; void</code></strong>
    Assigns a <code>state</code> to a specific grid cell at <code>pos</code>. The <code>state</code> can be either:<ul>
<li>A <code>Color</code>: The cell will be filled with this color.</li>
<li>A <code>Callable</code>: This function will be called during the <code>_draw()</code> process for this cell, receiving <code>(self, Rect2)</code> as arguments. <code>self</code> refers to the <code>GridVisualLogic</code> instance, and <code>Rect2</code> is the bounding rectangle of the cell in local coordinates. This allows for highly customized drawing.</li>
<li><code>pos</code>: The <code>Vector2i</code> coordinates of the cell to update.</li>
<li><code>state</code>: The <code>Color</code> or <code>Callable</code> to apply to the cell.</li>
</ul>
</li>
<li><strong><code>clear_cell_state(pos: Vector2i) -&gt; void</code></strong>
    Removes any custom state (color or callable) for the specified cell, making it transparent.<ul>
<li><code>pos</code>: The <code>Vector2i</code> coordinates of the cell to clear.</li>
</ul>
</li>
<li><strong><code>update_cells(states: Dictionary, clear_existing: bool = true) -&gt; void</code></strong>
    Replaces the entire <code>cell_states</code> dictionary with the provided <code>states</code> dictionary and redraws the grid. This is an efficient way to update many tiles at once.<ul>
<li><code>states</code>: A <code>Dictionary</code> where keys are <code>Vector2i</code> positions and values are <code>Color</code> or <code>Callable</code> states.</li>
<li><code>clear_existing</code>: If <code>true</code> (default), all existing cell states are cleared before applying the new ones. If <code>false</code>, new states are merged with existing ones.</li>
</ul>
</li>
<li><strong><code>log_event(t: String, actor: Object = null, pos: Variant = null, data: Variant = null) -&gt; void</code></strong>
    Appends a structured event to the module's internal <code>event_log</code>. Useful for debugging the visualizer's behavior.</li>
<li><strong><code>_draw() -&gt; void</code></strong>
    This is Godot's built-in callback method for custom drawing. <code>GridVisualLogic</code> overrides this to render the grid based on its <code>cell_states</code>. You typically don't call this directly; instead, you call <code>queue_redraw()</code> to trigger a redraw.</li>
<li><strong><code>run_tests() -&gt; Dictionary</code></strong>
    Executes a minimal self-test ensuring basic state management and drawing capabilities work as expected.</li>
</ul>
<h2>Usage</h2>
<pre><code class="language-gdscript"># Assuming LogicGridMap is available (e.g., from a RuntimeServices instance)
var map := LogicGridMap.new()
map.width = 4
map.height = 3

var vis := GridVisualLogic.new()
add_child(vis) # Add the visualizer to the scene tree

# Option 1: Connect to a LogicGridMap
vis.set_grid_map(map)

# Option 2: Manually set grid size if no LogicGridMap
# vis.set_grid_size(4, 3)

# Set a cell to a solid color (e.g., highlight a selected tile)
vis.set_cell_state(Vector2i(1, 1), Color.RED)

# Example of custom drawing using a Callable: Draw a yellow circle in a cell
vis.set_cell_state(Vector2i(0, 0), func(self_ref, rect_bounds):
    # self_ref refers to the GridVisualLogic instance
    # rect_bounds is the Rect2 for the current cell
    self_ref.draw_circle(rect_bounds.position + rect_bounds.size / 2, rect_bounds.size.x / 2, Color.YELLOW)
)

# To make changes visible, you must call queue_redraw()
vis.queue_redraw()

# Example of batch updating cells
var new_states = {
    Vector2i(2, 0): Color.BLUE,
    Vector2i(2, 1): Color.GREEN,
    Vector2i(2, 2): Color.PURPLE
}
vis.update_cells(new_states) # This will clear previous states and apply new ones
</code></pre>
<h2>Integration Notes</h2>
<ul>
<li><strong>Pure Visualization:</strong> Use this node strictly for visualization or debugging. It does not own game state or logic. All game logic should reside in other modules (like <code>LogicGridMap</code>, <code>TurnBasedGridTimespace</code>, etc.).</li>
<li><strong>Triggering Redraws:</strong> After modifying cell states (e.g., with <code>set_cell_state()</code> or <code>update_cells()</code>), you <strong>must</strong> call <code>queue_redraw()</code> on the <code>GridVisualLogic</code> instance to force the visualizer to update its display. Godot's immediate drawing API only redraws when explicitly requested or when the node's <code>_draw()</code> method is triggered by the engine.</li>
<li><strong>Resource Management in Tests:</strong> When using <code>GridVisualLogic</code> in unit tests, especially those that instantiate it in code, remember to free instances that inherit from <code>CanvasItem</code> (like <code>Node2D</code>) once you are done with them to avoid memory leaks.</li>
</ul>
<h2>Testing</h2>
<p>The module can be tested headlessly via the shared test runner:</p>
<pre><code class="language-bash">godot4 --headless --path . --script scripts/test_runner.gd -- --module=grid_visual_logic
</code></pre>
<p>The test verifies cell size assignment, color storage, and callable handling, ensuring the visualizer behaves correctly even without a graphical interface.</p>