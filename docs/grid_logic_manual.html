<h1>Grid Logic Module Manual</h1>
<p><code>grid_logic.gd</code> coordinates high-level tactical queries atop <code>LogicGridMap</code> and now supports procedural world generation using noise-driven biomes. It acts as an intermediary, providing convenient methods for common grid-related operations that might involve multiple underlying systems.</p>
<h2>Responsibilities</h2>
<ul>
<li>Wraps and manages a <code>LogicGridMap</code> instance, exposing simplified helpers for common queries.</li>
<li>Provides methods to check for actor presence and retrieve actors at specific locations.</li>
<li>Determines if an actor can move to a target tile, considering pathfinding and obstacles.</li>
<li>Computes "threatened tiles" (e.g., tiles within an actor's zone of control or attack range).</li>
<li>Orchestrates procedural world generation, replacing the current map with a newly generated one.</li>
</ul>
<h2>Core Concepts and API Details</h2>
<p>The <code>GridLogic</code> module serves as a facade over the more granular <code>LogicGridMap</code> and <code>ProceduralWorld</code> modules. This simplifies interactions for higher-level game logic, allowing developers to perform complex grid operations with single method calls.</p>
<h3>Class: <code>GridLogic</code> (inherits from <code>Node</code>)</h3>
<p>As a <code>Node</code>, <code>GridLogic</code> can be easily integrated into your game scene. It holds a reference to the active <code>LogicGridMap</code> instance.</p>
<h4>Members</h4>
<ul>
<li><strong><code>map</code></strong> (<code>Grid</code>, Default: <code>new()</code>): This member holds the active instance of the <code>LogicGridMap</code> (referred to as <code>Grid</code> in the API documentation). All spatial queries and updates performed by <code>GridLogic</code> are delegated to this underlying map.</li>
<li><strong><code>event_log</code></strong> (<code>Array</code>, Default: <code>[]</code>): An internal log for recording events related to grid logic, useful for debugging.</li>
</ul>
<h4>Methods</h4>
<ul>
<li><strong><code>log_event(t: String, actor: Object = null, pos: Variant = null, data: Variant = null) -&gt; void</code></strong>
    Records structured events for debugging and tests. This is a general-purpose logging method used internally.</li>
<li><strong><code>has_actor_at(pos: Vector2i) -&gt; bool</code></strong>
    Checks if there is any actor present at the specified grid position.<ul>
<li><code>pos</code>: The <code>Vector2i</code> coordinates to check.</li>
<li><strong>Returns:</strong> <code>true</code> if an actor occupies the tile, <code>false</code> otherwise.</li>
</ul>
</li>
<li><strong><code>get_actor_at(pos: Vector2i) -&gt; Variant</code></strong>
    Retrieves the actor object located at the specified grid position.<ul>
<li><code>pos</code>: The <code>Vector2i</code> coordinates to query.</li>
<li><strong>Returns:</strong> The <code>Object</code> representing the actor at <code>pos</code>, or <code>null</code> if no actor is found.</li>
</ul>
</li>
<li><strong><code>generate_world(width: int, height: int, seed: int = 0) -&gt; Color[]</code></strong>
    Generates a new procedural world map and replaces the current <code>map</code> (<code>LogicGridMap</code>) with the result. This method leverages the <code>ProceduralWorld</code> module internally.<ul>
<li><code>width</code>: The desired width of the new map in tiles.</li>
<li><code>height</code>: The desired height of the new map in tiles.</li>
<li><code>seed</code>: An optional integer seed for deterministic world generation. Using the same seed will produce the same map.</li>
<li><strong>Returns:</strong> An <code>Array</code> of <code>Color</code> objects representing the generated map, which can be used by visualizers (like <code>GridVisualLogic</code> or <code>GridRealtimeRenderer</code>) to display the terrain.</li>
</ul>
</li>
<li><strong><code>can_move(actor: Object, to: Vector2i) -&gt; bool</code></strong>
    Determines if a given <code>actor</code> can legally move to the specified target tile. This method internally uses the <code>LogicGridMap</code>'s pathfinding capabilities to check reachability and considers obstacles.<ul>
<li><code>actor</code>: The <code>Object</code> representing the actor attempting to move.</li>
<li><code>to</code>: The <code>Vector2i</code> coordinates of the target tile.</li>
<li><strong>Returns:</strong> <code>true</code> if the actor can reach the tile, <code>false</code> otherwise.</li>
</ul>
</li>
<li><strong><code>threatened_tiles(actor: Object) -&gt; Vector2i[]</code></strong>
    Calculates and returns an array of <code>Vector2i</code> coordinates representing tiles that are "threatened" by the given <code>actor</code>. This could include tiles within the actor's attack range, zone of control, or any other area where the actor exerts influence.<ul>
<li><code>actor</code>: The <code>Object</code> representing the actor whose threatened tiles are to be calculated.</li>
<li><strong>Returns:</strong> An <code>Array</code> of <code>Vector2i</code> coordinates.</li>
</ul>
</li>
<li><strong><code>run_tests() -&gt; Dictionary</code></strong>
    Executes internal self-tests for the <code>GridLogic</code> module, returning a dictionary of test results.</li>
</ul>
<h3>Interaction with <code>ProceduralWorld</code></h3>
<p>The <code>generate_world()</code> method within <code>GridLogic</code> delegates the actual map generation process to the <code>ProceduralWorld</code> module.</p>
<h4>Class: <code>ProceduralWorld</code> (inherits from <code>Node</code>)</h4>
<ul>
<li><strong>Purpose:</strong> This module (<code>procedural_world.gd</code>) is responsible for generating new game worlds based on various parameters, typically using noise algorithms to create varied terrain.</li>
<li><strong>Key API Role:</strong><ul>
<li><code>generate(width: int, height: int, seed: int = 0) -&gt; Dictionary</code>: This is the core method that creates the raw map data. It returns a dictionary containing the generated map information, which <code>GridLogic</code> then uses to populate its <code>LogicGridMap</code>.</li>
</ul>
</li>
<li><strong>Why it's separate:</strong> By separating the world generation logic, <code>GridLogic</code> remains focused on managing the active grid, while <code>ProceduralWorld</code> can be independently developed and tested for its generation algorithms.</li>
</ul>
<h2>Usage Example</h2>
<pre><code class="language-gdscript"># Assuming GridLogic is instantiated and added to the scene tree
@onready var grid_logic: GridLogic = $Path/To/GridLogic

func _ready() -&gt; void:
    # Generate a new 64x64 world with a specific seed
    var map_colors = grid_logic.generate_world(64, 64, 12345)
    print(&quot;Generated a new world map.&quot;)
    # You can then use map_colors to update a visual renderer, e.g.:
    # grid_visual_renderer.apply_color_map(map_colors)

    # Check if an actor exists at a specific position
    var check_pos = Vector2i(10, 15)
    if grid_logic.has_actor_at(check_pos):
        var actor_at_pos = grid_logic.get_actor_at(check_pos)
        print(&quot;Actor found at &quot; + str(check_pos) + &quot;: &quot; + str(actor_at_pos.name))
    else:
        print(&quot;No actor at &quot; + str(check_pos))

    # Assuming 'player_actor' is an instance of BaseActor
    var target_tile = Vector2i(12, 17)
    if grid_logic.can_move(player_actor, target_tile):
        print(&quot;Player can move to &quot; + str(target_tile))
    else:
        print(&quot;Player cannot move to &quot; + str(target_tile))

    # Get tiles threatened by the player
    var threatened = grid_logic.threatened_tiles(player_actor)
    print(&quot;Player threatens &quot; + str(threatened.size()) + &quot; tiles.&quot;)
    # You could then visualize these threatened tiles using GridRealtimeRenderer
    # grid_realtime_renderer.set_cells_color_bulk(threatened, Color(1, 0, 0, 0.2))
</code></pre>
<h2>Testing</h2>
<p>To ensure the <code>GridLogic</code> module functions correctly, execute its self-tests via the shared test runner:</p>
<pre><code class="language-bash">godot4 --headless --path . --script scripts/test_runner.gd -- --module=grid_logic
</code></pre>
<p>This command runs the tests headlessly, verifying that the module correctly wraps <code>LogicGridMap</code> operations, performs actor queries, and integrates with the procedural world generation.</p>