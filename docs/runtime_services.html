<h1>Runtime Service Overview</h1>
<p>This document summarizes the core logic modules that power the tactical runtime and explains how the <code>RuntimeServices</code> node aggregates them into a single, easily accessible point. Each module lives under <code>scripts/modules</code> and exposes a <code>run_tests()</code> helper so Continuous Integration (CI) systems and engineers can validate behavior headlessly.</p>
<h2>Core Logic Modules</h2>
<p>These are the independent, self-contained modules that <code>RuntimeServices</code> brings together:</p>
<h3><code>TurnBasedGridTimespace</code> (Turn Manager)</h3>
<ul>
<li><strong>Purpose:</strong> Orchestrates the flow of combat rounds and turns. It manages initiative, action point (AP) refresh, and deterministic ordering of actor actions.</li>
<li><strong>Key API Role:</strong><ul>
<li><strong>Phases:</strong> Manages the combat through distinct phases: <code>ROUND_START → ACTOR_START → ACTING → REACTION_WINDOWS → ACTOR_END → NEXT_ACTOR/ROUND_END</code>.</li>
<li><strong>Signals:</strong> Emits crucial signals such as <code>round_started()</code>, <code>turn_started(actor)</code>, <code>ap_changed(actor, old, new)</code>, and <code>action_performed(actor, action_id, payload)</code>. These signals allow UI or AI layers to respond to game state changes without tight coupling to the internal logic.</li>
</ul>
</li>
<li><strong>Further Reading:</strong> <a href="html/TurnBasedGridTimespace.html">TurnBasedGridTimespace API Documentation</a>, <a href="turn_timespace_manual.md">Turn Timespace Manual</a></li>
</ul>
<h3><code>LogicGridMap</code> (Spatial Authority)</h3>
<ul>
<li><strong>Purpose:</strong> The authoritative source for all spatial data on the tactical grid. It tracks bounds, occupancy, line of sight (LOS), and area-of-effect (AoE) templates.</li>
<li><strong>Key API Role:</strong> Supplies essential queries to other systems, including pathfinding (<code>find_path()</code>), cover calculations (<code>get_cover()</code>), and zone-of-control projections (<code>get_zone_of_control()</code>).</li>
<li><strong>Further Reading:</strong> <a href="html/GridLogic.html">LogicGridMap API Documentation</a>, <a href="grid_map_manual.md">Grid Map Manual</a></li>
</ul>
<h3><code>Attributes</code></h3>
<ul>
<li><strong>Purpose:</strong> The single source of truth for all numeric statistics (attributes) of actors. It handles base values and applies additive, multiplicative, and percentage modifiers with defined sources and durations.</li>
<li><strong>Key API Role:</strong> All gameplay logic must read attribute values via <code>get_value(actor, key)</code> to ensure modifiers are correctly applied.</li>
<li><strong>Further Reading:</strong> <a href="html/Attributes.html">Attributes API Documentation</a>, <a href="attributes_manual.md">Attributes Manual</a></li>
</ul>
<h3><code>Statuses</code></h3>
<ul>
<li><strong>Purpose:</strong> Manages buffs, debuffs, and other temporary or persistent stances applied to actors or tiles.</li>
<li><strong>Key API Role:</strong> <code>apply_status()</code> records new effects, while <code>tick()</code> decrements durations and notifies when statuses expire (via <code>status_removed</code> signal) so modifiers can be cleanly un-applied.</li>
<li><strong>Further Reading:</strong> <a href="html/Statuses.html">Statuses API Documentation</a>, <a href="statuses_manual.md">Statuses Manual</a></li>
</ul>
<h3><code>Abilities</code></h3>
<ul>
<li><strong>Purpose:</strong> Defines, validates requirements (tags, resources, range), and executes ordered effect lists for in-game abilities.</li>
<li><strong>Key API Role:</strong> Handles spending costs, setting cooldowns, and recording ability usage to the event log. <code>can_use()</code> checks if an ability is currently available, and <code>execute()</code> performs its effects.</li>
<li><strong>Further Reading:</strong> <a href="html/Abilities.html">Abilities API Documentation</a>, <a href="abilities_manual.md">Abilities Manual</a></li>
</ul>
<h3><code>Loadouts</code></h3>
<ul>
<li><strong>Purpose:</strong> Computes the set of abilities an actor can currently use based on their inherent traits, equipped items, and active statuses.</li>
<li><strong>Key API Role:</strong> <code>get_available(actor)</code> returns a list of ability IDs, feeding both UI hotbars and AI planners with the answer to "what can I use right now?"</li>
<li><strong>Further Reading:</strong> <a href="html/Loadouts.html">Loadouts API Documentation</a>, <a href="loadouts_manual.md">Loadouts Manual</a></li>
</ul>
<h3><code>Reactions</code></h3>
<ul>
<li><strong>Purpose:</strong> Manages a queue of interrupt abilities, such as attacks of opportunity or overwatch shots.</li>
<li><strong>Key API Role:</strong> Subscribes to movement or action triggers and queues reaction abilities. <code>resolve_next()</code> processes queued reactions by priority, while enforcing "once-per-turn" caps or other limits.</li>
<li><strong>Further Reading:</strong> <a href="html/Reactions.html">Reactions API Documentation</a>, <a href="reactions_manual.md">Reactions Manual</a></li>
</ul>
<h3><code>EventBus</code></h3>
<ul>
<li><strong>Purpose:</strong> An append-only stream of structured entries describing every significant state change in the game.</li>
<li><strong>Key API Role:</strong> Drives logging, analytics, and deterministic replays. Modules push events using <code>push()</code>, and the entire log can be serialized (<code>serialize()</code>) or replayed (<code>replay()</code>).</li>
<li><strong>Further Reading:</strong> <a href="html/EventBus.html">EventBus API Documentation</a>, <a href="event_bus_manual.md">Event Bus Manual</a></li>
</ul>
<h3><code>Terrain</code></h3>
<ul>
<li><strong>Purpose:</strong> A central registry of terrain types (e.g., grass, dirt, stone).</li>
<li><strong>Key API Role:</strong> Applies movement cost, Line of Sight (LOS) blockers, and tags to <code>LogicGridMap</code> tiles. It also allows for runtime mutation of terrain properties.</li>
<li><strong>Further Reading:</strong> <a href="html/Terrain.html">Terrain API Documentation</a>, <a href="terrain_manual.md">Terrain Manual</a></li>
</ul>
<h2>Real-world Usage: The <code>RuntimeServices</code> Aggregator</h2>
<p>The <code>RuntimeServices</code> node (<code>scripts/modules/runtime_services.gd</code>) is designed to simplify the setup and access of all these core logic modules within your gameplay scenes. Instead of instantiating and wiring each module individually, <code>RuntimeServices</code> does it for you.</p>
<h3>Class: <code>RuntimeServices</code> (inherits from <code>Node</code>)</h3>
<p><code>RuntimeServices</code> is a <code>Node</code> that acts as a container and central access point for all the core backend logic.</p>
<h4>Members</h4>
<p><code>RuntimeServices</code> exposes direct references to instances of all the core modules as its members. This means you can access any module's API through a single <code>services</code> object:</p>
<ul>
<li><strong><code>grid_map</code></strong> (<code>LogicGridMap</code>): Access to spatial queries, pathfinding, etc.</li>
<li><strong><code>timespace</code></strong> (<code>TurnBasedGridTimespace</code>): Access to turn management, actor registration, etc.</li>
<li><strong><code>attributes</code></strong> (<code>Attributes</code>): Access to attribute management, <code>get_value()</code>, etc.</li>
<li><strong><code>statuses</code></strong> (<code>Statuses</code>): Access to status application and management.</li>
<li><strong><code>abilities</code></strong> (<code>Abilities</code>): Access to ability validation and execution.</li>
<li><strong><code>loadouts</code></strong> (<code>Loadouts</code>): Access to actor ability loadouts.</li>
<li><strong><code>reactions</code></strong> (<code>Reactions</code>): Access to reaction queuing and resolution.</li>
<li><strong><code>event_bus</code></strong> (<code>EventBus</code>): Access to the central event log.</li>
</ul>
<h4>Example Usage</h4>
<pre><code class="language-gdscript"># In your main game scene script (e.g., Root.gd or a specific level scene)
var services := RuntimeServices.new()
add_child(services) # Add the RuntimeServices node to the scene tree

# Configure the grid map (e.g., its dimensions)
services.grid_map.width = 8
services.grid_map.height = 8

# Start the first round of the game
services.timespace.start_round()

# Abilities can be customized at runtime before execution:
services.abilities.register_ability(&quot;fire_bolt&quot;, {
    &quot;act_cost&quot;: 1,
    &quot;chi_cost&quot;: 2,
    &quot;cooldown&quot;: 1,
    &quot;effect&quot;: &quot;deal_damage&quot;, # Example custom effect data
    &quot;damage_amount&quot;: 10
})

# UI widgets or AI can subscribe to timespace or status signals to react to changes:
func _ready() -&gt; void:
    # Connect to signals from the aggregated modules
    services.timespace.ap_changed.connect(_on_ap_changed)
    services.statuses.status_applied.connect(_on_status_applied)

func _on_ap_changed(actor: Object, old_ap: int, new_ap: int) -&gt; void:
    # Example: Update a UI label showing an actor's AP
    if actor == watched_actor: # Assuming 'watched_actor' is a reference to the player
        ap_label.text = str(new_ap)

func _on_status_applied(actor: Object, id: String) -&gt; void:
    # Example: Display a visual indicator for a new status effect
    if actor == watched_actor:
        status_panel.show_status(id)
</code></pre>
<h2>Testing</h2>
<p><code>RuntimeServices</code> includes its own integration test to verify that all aggregated modules can operate together.</p>
<ul>
<li>
<p><strong>Execute the service's integration test and all module self-tests via the shared runner:</strong></p>
<p><code>bash
godot4 --headless --path . --script scripts/test_runner.gd -- --module=runtime_services</code></p>
<p>This command runs the tests headlessly. The <code>RuntimeServices</code> test typically involves moving an actor through the timespace, which in turn exercises the interactions between <code>TurnBasedGridTimespace</code>, <code>LogicGridMap</code>, <code>Attributes</code>, and <code>Statuses</code>. It also delegates to each individual module's <code>run_tests()</code> method, ensuring comprehensive coverage.</p>
</li>
</ul>
<h3>Pitfalls to Avoid</h3>
<ul>
<li><strong>Resource Leaks in Headless Tests:</strong> When running headless tests, always ensure that you explicitly free instantiated modules (e.g., <code>services.free()</code>) to prevent memory leaks, especially for <code>Node</code>s.</li>
<li><strong><code>timespace.set_grid_map()</code>:</strong> It is crucial that <code>timespace.set_grid_map()</code> is invoked before starting the timespace (e.g., <code>timespace.start_round()</code>). <code>RuntimeServices</code> handles this internally during its <code>_ready()</code> method, but if you are setting up modules manually, you must call it explicitly to link the turn manager to the game grid.</li>
</ul>