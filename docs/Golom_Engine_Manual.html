
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Golom Engine User's Guide</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            line-height: 1.6;
            color: #333;
            max-width: 960px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f9f9f9;
        }
        h1, h2, h3, h4, h5, h6 {
            font-weight: 600;
            margin-top: 1.5em;
            margin-bottom: 0.5em;
            color: #111;
        }
        h1 {
            font-size: 2.5em;
            border-bottom: 2px solid #eee;
            padding-bottom: 10px;
        }
        h2 {
            font-size: 2em;
            border-bottom: 1px solid #eee;
            padding-bottom: 8px;
        }
        h3 {
            font-size: 1.5em;
        }
        a {
            color: #0366d6;
            text-decoration: none;
        }
        a:hover {
            text-decoration: underline;
        }
        code {
            font-family: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, Courier, monospace;
            background-color: #f0f0f0;
            padding: 2px 5px;
            border-radius: 4px;
            font-size: 0.9em;
        }
        pre {
            background-color: #2d2d2d;
            color: #f1f1f1;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            white-space: pre-wrap;
            word-wrap: break-word;
        }
        pre code {
            background-color: transparent;
            padding: 0;
            border-radius: 0;
            color: inherit;
        }
        ul, ol {
            padding-left: 20px;
        }
        li {
            margin-bottom: 5px;
        }
        table {
            border-collapse: collapse;
            width: 100%;
            margin-top: 1em;
            margin-bottom: 1em;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
        }
        th {
            background-color: #f2f2f2;
            font-weight: bold;
        }
        blockquote {
            border-left: 4px solid #ddd;
            padding-left: 15px;
            color: #555;
            margin-left: 0;
        }
        .toc {
            background-color: #fff;
            border: 1px solid #ddd;
            border-radius: 5px;
            padding: 20px;
            margin-bottom: 30px;
        }
        .toc h2 {
            margin-top: 0;
            border-bottom: none;
        }
        .toc ul {
            padding-left: 0;
            list-style-type: none;
        }
        .toc > ul > li > ul {
             padding-left: 20px;
             margin-top: 10px;
        }
        .toc > ul > li > a {
            font-weight: bold;
        }
    </style>
</head>
<body>
    <h1>Golom Engine User's Guide</h1>

    <div class="toc">
        <h2>Table of Contents</h2>
        <ul>
            <li><a href="#high-level-overviews">High-Level Overviews</a>
                <ul>
                    <li><a href="#game_overview">Game Overview</a></li>
                    <li><a href="#developer_overview">Developer Overview</a></li>
                    <li><a href="#backend_architecture">Backend Architecture</a></li>
                    <li><a href="#logic_flow_guide">Logic Flow Guide</a></li>
                </ul>
            </li>
            <li><a href="#core-system-manuals">Core System Manuals</a>
                <ul>
                    <li><a href="#grid_map_manual">Grid Map Manual</a></li>
                    <li><a href="#turn_timespace_manual">Turn Timespace Manual</a></li>
                    <li><a href="#attributes_manual">Attributes Manual</a></li>
                    <li><a href="#statuses_manual">Statuses Manual</a></li>
                    <li><a href="#abilities_manual">Abilities Manual</a></li>
                    <li><a href="#loadouts_manual">Loadouts Manual</a></li>
                    <li><a href="#reactions_manual">Reactions Manual</a></li>
                    <li><a href="#event_bus_manual">Event Bus Manual</a></li>
                    <li><a href="#terrain_manual">Terrain Manual</a></li>
                </ul>
            </li>
            <li><a href="#procedural-generation-rendering">Procedural Generation & Rendering</a>
                <ul>
                    <li><a href="#map_generator_manual">Map Generator Manual</a></li>
                    <li><a href="#procedural_map_manual">Procedural Map Manual</a></li>
                    <li><a href="#procedural_world_manual">Procedural World Manual</a></li>
                    <li><a href="#grid_realtime_renderer_manual">Grid Realtime Renderer Manual</a></li>
                    <li><a href="#grid_visual_logic">Grid Visual Logic</a></li>
                    <li><a href="#renderer_turn_timespace_tutorial">Renderer & Turn Timespace Tutorial</a></li>
                </ul>
            </li>
            <li><a href="#headless-ascii-tools">Headless & ASCII Tools</a>
                <ul>
                    <li><a href="#headless_tooling">Headless Tooling</a></li>
                    <li><a href="#headless_ascii_mode">Headless ASCII Mode</a></li>
                    <li><a href="#ascii_engine_manual">ASCII Engine Manual</a></li>
                </ul>
            </li>
            <li><a href="#gameplay-feature-design">Gameplay & Feature Design</a>
                <ul>
                    <li><a href="#character_creation_manual">Character Creation Manual</a></li>
                    <li><a href="#humanizer_manual">Humanizer Manual</a></li>
                    <li><a href="#grid_interactor_manual">Grid Interactor Manual</a></li>
                </ul>
            </li>
            <li><a href="#project-proposals-planning">Project Proposals & Planning</a>
                <ul>
                    <li><a href="#vertical_slice_proposal">Vertical Slice Proposal</a></li>
                    <li><a href="#upgrade_plan_outline">Upgrade Plan Outline</a></li>
                </ul>
            </li>
            <li><a href="#internal-operations-debugging">Internal Operations & Debugging</a>
                <ul>
                    <li><a href="#OPERATIONS">OPERATIONS</a></li>
                    <li><a href="#INTERNAL_DEBUGGER">INTERNAL_DEBUGGER</a></li>
                    <li><a href="#runtime_services">Runtime Services</a></li>
                    <li><a href="#gdscript_indentation_and_formatting">GDScript Indentation and Formatting</a></li>
                </ul>
            </li>
            <li><a href="#api-reference">API Reference</a>
                <ul>
                    <li><a href="#api_readme">API README</a></li>
                </ul>
            </li>
        </ul>
    </div>

    <h2 id="high-level-overviews">High-Level Overviews</h2>

    <section id="game_overview">
        <h3>Game Overview</h3>
        <p>This project organizes tactical role-playing game logic into discrete Godot modules. Each module owns a narrow slice of the ruleset and communicates with others through simple method calls or Godot signals. This section gives outside engineers a high-level map for navigating the runtime, explaining how these tools work together and why.</p><h3>Core Concepts: The Building Blocks of Golom</h3><p>Golom's game logic is built upon several interconnected modules, each specializing in a core aspect of the game. Understanding these modules and their APIs is key to building and extending the game.</p><ul><li><p><strong><code>LogicGridMap</code></strong></p><ul><li><strong>Purpose:</strong> This module (<code>grid_map.gd</code>) is the pure data container for all spatial information in the game world. It handles grid coordinates, terrain tags, and the physical presence of actors. It's the foundation for anything that needs to know about &quot;where&quot; things are.</li><li><strong>Key API Role:</strong> Provides methods for spatial queries (e.g., <code>is_in_bounds()</code>, <code>is_occupied()</code>), pathfinding (<code>find_path()</code>), and line of sight (<code>has_line_of_sight()</code>). It doesn't handle visual rendering directly but provides the data for it.</li><li><strong>Why it's separate:</strong> By separating spatial data from visual representation, the game can run headless (without graphics) for testing or server-side logic, and allows for flexible visual layers.</li><li><strong>Further Reading:</strong> <a href="html/GridLogic.html">LogicGridMap API Documentation</a>, <a href="grid_map_manual.md">Grid Map Manual</a></li></ul></li><li><p><strong><code>TurnBasedGridTimespace</code></strong></p><ul><li><strong>Purpose:</strong> This module (<code>turn_timespace.gd</code>) acts as the central state machine for turn-based combat. It orchestrates the flow of rounds and turns, manages action points (AP), and handles the initiative order of all actors.</li><li><strong>Key API Role:</strong> Methods like <code>start_round()</code> and <code>end_turn()</code> drive the game's temporal progression. It manages actor AP and triggers status effect processing. It also emits crucial signals like <code>round_started</code>, <code>turn_started</code>, and <code>ap_changed</code> to notify other systems of game state changes.</li><li><strong>Why it's central:</strong> By centralizing turn management, the game ensures consistent application of rules and provides clear points for other modules (like UI or AI) to synchronize with the game's flow.</li><li><strong>Further Reading:</strong> <a href="html/TurnBasedGridTimespace.html">TurnBasedGridTimespace API Documentation</a>, <a href="turn_timespace_manual.md">Turn Timespace Manual</a></li></ul></li><li><p><strong><code>Attributes</code></strong></p><ul><li><strong>Purpose:</strong> This module (<code>attributes.gd</code>) is the central authority for all numeric statistics (attributes) of actors. It handles base values, applies various types of modifiers (additive, multiplicative, percentage), and enforces clamped ranges.</li><li><strong>Key API Role:</strong> The <code>get_value(actor, key)</code> method is paramount; <strong>all systems must query attribute values through this method</strong> to ensure modifiers and ranges are correctly applied. Methods like <code>set_base()</code> and <code>add_modifier()</code> allow for dynamic changes to attributes.</li><li><strong>Why it's centralized:</strong> Funneling all attribute reads and modifications through this single service ensures consistency, prevents bugs from direct field manipulation, and makes auditing attribute calculations much easier.</li><li><strong>Further Reading:</strong> <a href="html/Attributes.html">Attributes API Documentation</a>, <a href="attributes_manual.md">Attributes Manual</a></li></ul></li><li><p><strong><code>Statuses</code></strong></p><ul><li><strong>Purpose:</strong> This module (<code>statuses.gd</code>) manages temporary or persistent status effects (buffs and debuffs) applied to actors or even specific tiles.</li><li><strong>Key API Role:</strong> <code>apply_status()</code> adds effects, and <code>tick()</code> (called by <code>TurnBasedGridTimespace</code>) reduces durations and purges expired statuses. Signals like <code>status_applied</code> and <code>status_removed</code> inform other modules of changes.</li><li><strong>Why it's separate:</strong> Isolating status effect logic simplifies their management, allowing for complex interactions without cluttering actor definitions. It also ensures consistent application and removal of effects.</li><li><strong>Further Reading:</strong> <a href="html/Statuses.html">Statuses API Documentation</a>, <a href="statuses_manual.md">Statuses Manual</a></li></ul></li><li><p><strong><code>Abilities</code> &amp; <code>Loadouts</code></strong></p><ul><li><strong>Purpose:</strong><ul><li><strong><code>Abilities</code></strong> (<code>abilities.gd</code>): Defines, validates, and executes active abilities. It handles resource costs, cooldowns, and the core logic of what an ability does.</li><li><strong><code>Loadouts</code></strong> (<code>loadouts.gd</code>): Determines which abilities an actor currently has access to, based on factors like equipment, class, or active status effects.</li></ul></li><li><strong>Key API Role:</strong> <code>Abilities.can_use()</code> checks if an actor meets the requirements (e.g., AP, cooldowns via <code>Attributes</code>). <code>Abilities.execute()</code> performs the ability. <code>Loadouts.get_available()</code> provides the list of usable abilities to UI or AI.</li><li><strong>Why they work together:</strong> <code>Loadouts</code> acts as a filter or grant system for <code>Abilities</code>. This separation allows designers to easily define new abilities and then control their availability to different actors without modifying core ability logic.</li><li><strong>Further Reading:</strong> <a href="html/Abilities.html">Abilities API Documentation</a>, <a href="html/Loadouts.html">Loadouts API Documentation</a>, <a href="abilities_manual.md">Abilities Manual</a>, <a href="loadouts_manual.md">Loadouts Manual</a></li></ul></li><li><p><strong><code>Reactions</code></strong></p><ul><li><strong>Purpose:</strong> This module (<code>reactions.gd</code>) provides a lightweight interrupt system for &quot;opportunity actions&quot; or reactions that occur in response to specific game events (e.g., an attack of opportunity when an enemy moves into range).</li><li><strong>Key API Role:</strong> <code>trigger()</code> queues a reaction, and <code>resolve_next()</code> processes the next one.</li><li><strong>Why it's separate:</strong> It allows for complex reactive behaviors without tightly coupling them into the main turn sequence, making the game logic more flexible and extensible.</li><li><strong>Further Reading:</strong> <a href="html/Reactions.html">Reactions API Documentation</a>, <a href="reactions_manual.md">Reactions Manual</a></li></ul></li><li><p><strong><code>EventBus</code></strong></p><ul><li><strong>Purpose:</strong> This module (<code>event_bus.gd</code>) is an append-only log that captures every significant state change or event in the game.</li><li><strong>Key API Role:</strong> <code>push(evt)</code> is used by all other modules to record structured event dictionaries. <code>serialize()</code> and `replay()` enable saving, loading, and replaying game sessions deterministically.</li><li><strong>Why it's crucial:</strong> It's fundamental for debugging (seeing the exact sequence of events), analytics (collecting data on gameplay), and enabling deterministic replays (recreating a game session exactly as it happened).</li><li><strong>Further Reading:</strong> <a href="html/EventBus.html">EventBus API Documentation</a>, <a href="event_bus_manual.md">Event Bus Manual</a></li></ul></li><li><p><strong>`GridVisualLogic`</strong></p><ul><li><strong>Purpose:</strong> This module (`grid_visual_logic.gd`) is an immediate-mode renderer primarily used for debugging grid state or powering a minimal UI. It allows developers to draw colors or custom shapes directly onto grid cells.</li><li><strong>Key API Role:</strong> `set_cell_state()` and `update_cells()` allow for dynamic visual feedback on the grid.</li><li><strong>Why it's separate:</strong> It provides a quick and easy way to visualize the underlying `LogicGridMap` data without needing complex 3D models or extensive UI setup, making debugging much faster.</li><li><strong>Further Reading:</strong> <a href="html/GridVisualLogic.html">GridVisualLogic API Documentation</a>, <a href="grid_visual_logic.md">Grid Visual Logic Manual</a></li></ul></li></ul><p>Modules are intentionally decoupled so they can be instantiated or swapped independently inside tests or gameplay scenes. The `scripts/test_runner.gd` scene shows how to run their self-tests headlessly.</p><h3>Execution Flow: A Turn in Action</h3><p>Understanding how these modules interact during a typical game turn is essential. The `TurnBasedGridTimespace` module acts as the central coordinator.</p><ol><li><strong>Round Start:</strong> `TurnBasedGridTimespace.start_round()` is called. This resets each actor's action points and emits the `round_started` signal. It also triggers `Statuses.tick()` to process any round-start effects.</li><li><strong>Turn Begins:</strong> `TurnBasedGridTimespace` initiates an actor's turn, emitting the `turn_started` signal and applying any `turn_start` statuses via the `Statuses` module.</li><li><strong>Ability Selection:</strong> External logic (e.g., player UI) queries `Loadouts.get_available()` to see what abilities an actor has. For each ability, `Abilities.can_use()` is called, which consults `Attributes.get_value()` to check for sufficient resources and cooldowns.</li><li><strong>Action Execution:</strong> When an action is performed (e.g., movement, ability use), `TurnBasedGridTimespace` handles AP expenditure. Movement actions delegate to `LogicGridMap.move_actor()` for spatial updates. Successful actions emit `action_performed` and `ap_changed` signals. If an ability is used, `Abilities.execute()` is called.</li><li><strong>Reactions:</strong> After certain actions (like movement), `TurnBasedGridTimespace` might check for reactions (e.g., using `LogicGridMap.has_line_of_sight()`). If a reaction is triggered, the `Reactions` module is notified to queue and resolve it.</li><li><strong>Status Handling:</strong> Throughout the turn, abilities or other game effects can call `TurnBasedGridTimespace.apply_status_to_actor()`, which interacts with the `Statuses` module. `Statuses` emits `status_applied` and `status_removed` signals as effects begin or end.</li><li><strong>Event Logging:</strong> Crucially, at each significant step, modules push structured event dictionaries to the `EventBus` using its `push()` method. This creates a complete, chronological record of the game state.</li><li><strong>Turn End:</strong> `TurnBasedGridTimespace.end_turn()` is called, emitting `turn_ended`, processing `turn_end` statuses, and advancing to the next actor or ending the round.</li></ol><p>This coordinated dance of method calls and signals ensures that all game logic is processed consistently and that other systems can react appropriately.</p><h3>Integration Tips for Developers</h3><ul><li><strong>Treat Modules as Services:</strong> Think of each module (e.g., `Attributes`, `Statuses`) as a self-contained service. Instantiate the ones you need and inject them into your game scenes or other modules. This promotes modularity and reusability.</li><li><strong>Leverage Signals for Loose Coupling:</strong> Use Godot's signals (`turn_started`, `ap_changed`, `status_applied`, etc.) extensively. This is the primary mechanism for modules to communicate without directly knowing about each other's internal implementations. This keeps UI and AI layers loosely coupled from the core game logic.</li><li><strong>Run Module Self-Tests Frequently:</strong> The `scripts/test_runner.gd` script is your best friend. Run it often with `godot4 --headless --path . --script scripts/test_runner.gd` to ensure deterministic behavior across platforms and to catch regressions early. Each module's `run_tests()` method provides a quick way to verify its functionality.</li><li><strong>Minimal Public APIs, Data-Driven Rules:</strong> When extending modules or adding new features, strive to keep public APIs minimal and well-defined. Prefer using data-driven dictionaries for new rules (e.g., ability definitions, status effects) rather than hardcoding them into scripts. This allows designers to iterate on gameplay without requiring code changes.</li><li><strong>Consult Specific Manuals:</strong> This overview provides a map. For in-depth API usage, examples, and specific implementation details for each module, refer to its dedicated manual in the `docs/` folder and its corresponding HTML API documentation in `docs/html/`.</li>
    </section>

    <section id="developer_overview">
        <h3>Developer Overview</h3>
        <p>This document provides an exhaustive cross-reference of the Golom tactical RPG project for outside engineers. It surveys every script and module, details their responsibilities, and highlights interactions between systems. The goal is to consolidate knowledge currently scattered across scripts and existing manuals, giving contributors a single reference point.</p><h3>Project Layout</h3><p>The project follows a clear directory structure to organize its components:</p><pre><code>res://scripts/
  core/                # bootstrapping scenes and base actor definition
  grid/                # grid-specific resources and interaction helpers
  modules/             # self-contained logic services
  tests/               # isolated scene tests
  test_runner.gd       # headless aggregate test harness
</code></pre><p>Visual assets and scenes live under <code>res://scenes/</code>, while comprehensive documentation, including API details and manuals, resides in <code>docs/</code>.</p><h3>Core Scripts (<code>scripts/core</code>)</h3><p>These scripts handle the fundamental setup and management of the game's core entities and development environment.</p><h4><code>base_actor.gd</code> - <code>BaseActor</code></h4><p>Defines the <strong>BaseActor</strong> class, a lightweight template for any creature or entity placed on the grid. It's designed to be extended by specific actor types (e.g., player, enemy, NPC).</p><ul><li><strong>Key Data:</strong> Stores essential gameplay data such as:<ul><li><code>grid_pos</code>: Current position on the <code>LogicGridMap</code>.</li><li><code>facing</code>: Direction the actor is facing.</li><li><code>size</code>: Physical size on the grid (e.g., 1x1, 2x2).</li><li><code>faction</code>: A string identifying the actor's allegiance (e.g., &quot;player&quot;, &quot;enemy&quot;, &quot;neutral&quot;).</li><li>Gameplay stats: Health (<code>HLTH</code>), Chi (<code>CHI</code>), Action Points (<code>ACT</code>), Initiative (<code>INIT</code>), status flags, and core attributes (power, speed, focus, capacity, perception).</li><li>Harvestable rewards: XP, loot, quest tokens, and script triggers.</li></ul></li><li><strong>Utility:</strong> The <code>describe()</code> helper method outputs a human-readable summary of the actor's state, useful for debugging.</li><li><strong>API Reference:</strong> While <code>BaseActor</code> itself doesn't have a dedicated API HTML document, its properties are heavily utilized by modules like <code>Attributes</code> and <code>TurnBasedGridTimespace</code>.</li></ul><h4><code>workspace.gd</code> - <code>Workspace</code></h4><p>Implements an interactive <strong>Workspace</strong> scene, primarily used for loading modules and running their tests. This is a developer-facing tool to ensure module stability.</p><ul><li><strong>Functionality:</strong><ul><li>Provides a GUI to list each module, its load status, pass/fail test result, and a button to view detailed logs.</li><li>Supports command-line flags (<code>--module</code> / <code>--modules</code>) to restrict which modules load and run tests.</li><li>Emits a <code>tests_completed</code> signal with a summary dictionary, allowing for automated reporting.</li><li>Supports looping test execution for long-running stability checks.</li><li>Includes a dedicated Map Generator tab that runs procedural world creation on a background thread, showing a pulsing progress bar and allowing export of the resulting color map.</li></ul></li><li><strong>API Reference:</strong> This is an internal tool, so it doesn't have a public API document.</li></ul><h4><code>workspace_debugger.gd</code></h4><p>A small utility script that logs workspace events and errors to <code>user://workspace_errors.log</code> for later inspection. Both informational and error messages funnel through its <code>_log()</code> method. This is crucial for diagnosing issues within the development environment.</p><h4><code>grid_default_map.gd</code></h4><p>This script is responsible for setting up a default demo grid for testing and development.</p><ul><li><strong>Functionality:</strong><ul><li>Loads a 32x32 demo grid.</li><li>Instantiates three color-coded actors (green player, red enemy, blue NPC).</li><li>Preloads the <code>RuntimeServices</code> aggregator (see below) and an optional <code>GridRealtimeRenderer</code> for visual debugging when a display is available.</li><li>Actors are positioned using <code>TurnBasedGridTimespace.add_actor()</code> and rendered via <code>GridVisualLogic.set_cell_color()</code>.</li></ul></li><li><strong>Interaction:</strong> Demonstrates the initial setup and interaction with <code>RuntimeServices</code>, <code>TurnBasedGridTimespace</code>, and <code>GridVisualLogic</code>.</li></ul><h4><code>root.gd</code></h4><p>The primary entry point scene for the game.</p><ul><li><strong>Functionality:</strong><ul><li>Instantiates the <code>Workspace</code> scene.</li><li>Listens for the <code>Workspace</code>'s <code>tests_completed</code> signal.</li><li>If all module tests pass, it proceeds to load <code>GridDefaultMap.tscn</code> to provide an interactive sandbox for gameplay.</li><li>Can enable continuous background testing via <code>workspace.start_loop()</code>.</li></ul></li></ul><h3>Grid Utilities (<code>scripts/grid</code>)</h3><p>These scripts provide the foundational logic for managing the game's grid-based world and interactions within it.</p><h4><code>grid_map.gd</code> – <code>LogicGridMap</code></h4><p>The <code>LogicGridMap</code> is a critical <code>Resource</code> that encapsulates all tactical spatial logic for the game world. It's a data-driven representation of the grid, separate from its visual rendering.</p><ul><li><strong>Key Responsibilities &amp; API Highlights:</strong><ul><li><strong>Actor Placement:</strong> Tracks occupied tiles (<code>occupied</code> member) and actor origins (<code>actor_positions</code> member).<ul><li><code>move_actor(actor: Object, from_pos: Vector2i, to_pos: Vector2i) -> bool</code>: Validates and performs actor movement, handling multi-tile footprints.</li><li><code>remove_actor(actor: Object) -> void</code>: Clears an actor's entries from the map.</li><li><code>get_occupied_tiles() -> Array</code>: Returns all currently occupied tile positions.</li><li><code>get_all_actors() -> Array</code>: Returns all actors currently on the map.</li></ul></li><li><strong>Spatial Queries:</strong><ul><li><code>is_in_bounds(pos: Vector2i) -> bool</code>: Checks if a position is within the grid boundaries.</li><li><code>is_occupied(pos: Vector2i) -> bool</code>: Checks if a tile is occupied by an actor.</li><li>Distance helpers (<code>get_distance</code>, <code>get_chebyshev_distance</code>).</li><li><code>has_line_of_sight(from_pos: Vector2i, to_pos: Vector2i) -> bool</code>: Uses Bresenham's algorithm to check for unobstructed line of sight, considering LOS blockers and cover.</li></ul></li><li><strong>Range Queries:</strong><ul><li><code>get_actors_in_radius(center: Vector2i, radius: int) -> Array</code>: Finds actors within a given radius.</li><li><code>get_positions_in_range(center: Vector2i, radius: int) -> Array</code>: Finds all positions within a given radius.</li></ul></li><li><strong>Pathfinding:</strong><ul><li><code>find_path(start: Vector2i, end: Vector2i, actor: Object = null) -> Array</code>: Implements A* pathfinding, considering movement costs, turning penalties (<code>TURN_COST</code> constant), climb restrictions, and multi-tile actor support.</li><li><code>find_path_for_actor(actor: Object, start: Vector2i, end: Vector2i) -> Array</code>: A wrapper for `find_path` that uses the actor's size and facing.</li></ul></li><li><strong>Area-of-Effect (AoE) Shapes:</strong> Provides methods for calculating tiles within various AoE shapes (burst, cone, line, wall) via `get_aoe_tiles()`.</li><li><strong>Tactical Logic:</strong> Supports zone-of-control projection (`get_zone_of_control`), flanking checks, cover handling, per-tile movement costs, and height levels.</li><li><strong>Event Logging:</strong> `log_event()` appends non-error messages for debugging.</li></ul></li><li><strong>API Reference:</strong> <a href="html/GridLogic.html">LogicGridMap API Documentation</a> (Note: The API doc is named `GridLogic.html` but refers to the `LogicGridMap` class).</li></ul><h4>`grid_interactor.gd` – `GridInteractor`</h4><p>A `Node2D` script that translates mouse input into grid interactions, making the grid interactive for players or developers.</p><ul><li><strong>Key Functionality &amp; API Highlights:</strong><ul><li><strong>Input Handling:</strong> Processes mouse clicks, drags, and selections on the grid.</li><li><strong>Signals:</strong> Emits various signals to notify other systems of interactions:<ul><li>`tile_clicked(pos: Vector2i)`</li><li>`tiles_selected(positions: Array)`</li><li>`actor_clicked(actor: Object)`</li><li>`actors_selected(actors: Array)`</li></ul></li><li><strong>Features:</strong> Includes drag-selection previews using `GridRealtimeRenderer`, modifier key bitmask helpers (Shift for adding to selection, Ctrl for toggling), and stateful drag handling to differentiate simple clicks from marquee selections.</li></ul></li><li><strong>API Reference:</strong> This is a UI-focused script and does not have a direct API HTML document, but it interacts heavily with `GridRealtimeRenderer`.</li><li><strong>Usage Details:</strong> See `grid_interactor_manual.md` for usage details and signal wiring examples.</li></ul><h3>Logic Modules (`scripts/modules`)</h3><p>Each module in this directory is designed to be self-contained and loosely coupled, focusing on a specific domain of game logic. They typically expose a `run_tests()` method for headless verification, facilitating automated testing.</p><h4>Spatial &amp; Timeline Modules</h4><p>These modules manage the game's temporal and spatial state, beyond the basic grid structure.</p><ul><li><p><strong>`turn_timespace.gd` - `TurnBasedGridTimespace`</strong></p><ul><li><strong>Purpose:</strong> The central orchestrator for turn-based combat. It manages rounds, initiative order, action points (AP), reactions, status ticking, and serialization of the game state.</li><li><strong>Key API:</strong><ul><li>`start_round()`, `end_turn()`: Control the flow of turns and rounds.</li><li>`add_actor()`, `get_current_actor()`: Manage actors within the turn order.</li><li>`register_action()`, `perform()`: Define and execute actions.</li><li>Signals: `round_started`, `turn_started`, `ap_changed`, `action_performed`, `damage_applied`, etc., provide real-time updates to other systems.</li></ul></li><li><strong>Interaction:</strong> Interacts heavily with `Statuses` (for ticking effects), `Abilities` (for executing actions), and `LogicGridMap` (for spatial updates). It also pushes events to the `EventBus`.</li><li><strong>Testing:</strong> Extensive self-tests cover initiative stability, AP spending, overwatch, status durations, serialization, and event log schema.</li><li><strong>API Reference:</strong> <a href="html/TurnBasedGridTimespace.html">TurnBasedGridTimespace API Documentation</a></li><li><strong>Manual:</strong> See `turn_timespace_manual.md` for more details.</li></ul></li><li><p><strong>`grid_logic.gd`</strong></p><ul><li><strong>Purpose:</strong> This module is currently a placeholder stub, primarily used for logging a self-test message. It is intended to house higher-level grid-related game logic that might not fit directly into `LogicGridMap`'s spatial management.</li><li><strong>API Reference:</strong> <a href="html/GridLogic.html">GridLogic API Documentation</a></li></ul></li><li><p><strong>`grid_visual_logic.gd` - `GridVisualLogic`</strong></p><ul><li><strong>Purpose:</strong> An immediate-mode renderer designed for debugging or minimal UI visualization of the grid. It allows for drawing colors or custom callables on individual cells.</li><li><strong>Key API:</strong><ul><li>`set_grid_map()`, `set_grid_size()`: Configure the grid dimensions.</li><li>`set_cell_state()`, `clear_cell_state()`, `update_cells()`: Control what is drawn on each cell.</li><li>`log_event()`: For internal debugging.</li></ul></li><li><strong>Interaction:</strong> Often used in conjunction with `LogicGridMap` to visualize its state.</li><li><strong>API Reference:</strong> <a href="html/GridVisualLogic.html">GridVisualLogic API Documentation</a></li></ul></li><li><p><strong>`GridRealtimeRenderer.gd`</strong></p><ul><li><strong>Purpose:</strong> A high-performance visual overlay for the grid, built on Godot's `MultiMeshInstance2D` for efficient rendering of many small elements. It's used for displaying complex visual feedback like fills, glyphs, strokes, and heatmaps.</li><li><strong>Key API:</strong><ul><li>`set_ascii_entity()`, `clear_ascii_entities()`, `remove_ascii_actor()`: Manage ASCII character overlays.</li><li>`begin_labels()`, `push_label()`, `end_labels()`: For rendering text labels on the grid.</li><li>`apply_heatmap_auto()`, `apply_heatmap()`: Visualize numerical data as heatmaps.</li><li>`set_mark()`, `set_stroke()`, `set_hatch()`: Draw various visual markers and patterns.</li></ul></li><li><strong>Interaction:</strong> Used by `GridInteractor` for drag-selection previews and can be used by any module needing rich visual feedback on the grid.</li><li><strong>API Reference:</strong> <a href="html/GridRealtimeRenderer.html">GridRealtimeRenderer API Documentation</a></li></ul></li></ul><h4>Actor Data &amp; Effects Modules</h4><p>These modules manage the attributes, status effects, abilities, and reactions of actors within the game.</p><ul><li><p><strong>`attributes.gd` - `Attributes`</strong></p><ul><li><strong>Purpose:</strong> Centralizes all numeric statistics for actors. It handles base values, additive, multiplicative, and percentage modifiers, and ensures values are clamped within defined ranges.</li><li><strong>Key API:</strong><ul><li>`set_base()`, `add_modifier()`, `clear_modifiers()`: Manage attribute values and their modifications.</li><li>`get_value()`: <strong>The primary method to query an actor's final attribute value</strong>, considering all modifiers and ranges.</li><li>`set_range()`: Defines min/max bounds for attributes.</li></ul></li><li><strong>Interaction:</strong> Heavily used by `Abilities` (for cost checks) and `Statuses` (for applying attribute-modifying effects).</li><li><strong>API Reference:</strong> <a href="html/Attributes.html">Attributes API Documentation</a></li><li><strong>Manual:</strong> See `attributes_manual.md` for more details.</li></ul></li><li><p><strong>`statuses.gd` - `Statuses`</strong></p><ul><li><strong>Purpose:</strong> Tracks and manages buffs/debuffs and other temporary status effects on actors and tiles, including their stacks and durations.</li><li><strong>Key API:</strong><ul><li>`apply_status()`: Applies a new status effect.</li><li>`tick()`: Decrements durations of all active statuses and removes expired ones.</li><li>Signals: `status_applied`, `status_removed` notify other systems of changes.</li></ul></li><li><strong>Interaction:</strong> `TurnBasedGridTimespace` calls `tick()` on `Statuses`. `Statuses` interacts with `Attributes` to apply the numerical effects of statuses.</li><li><strong>API Reference:</strong> <a href="html/Statuses.html">Statuses API Documentation</a></li><li><strong>Manual:</strong> See `statuses_manual.md` for more details.</li></ul></li><li><p><strong>`abilities.gd` - `Abilities`</strong></p><ul><li><strong>Purpose:</strong> Registers ability definitions, validates if an actor can use an ability, and executes the ability's logic.</li><li><strong>Key API:</strong><ul><li>`register_ability()`, `load_from_file()`: Define and load abilities.</li><li>`can_use()`: Checks if an ability can be used (integrates with `Attributes` for cost checks).</li><li>`execute()`: Runs the ability's effects.</li><li>`tick_cooldowns()`: Manages ability cooldowns.</li></ul></li><li><strong>Interaction:</strong> `Loadouts` determines which abilities are available. `Abilities` uses `Attributes` for resource management and `TurnBasedGridTimespace` for event logging and signaling.</li><li><strong>API Reference:</strong> <a href="html/Abilities.html">Abilities API Documentation</a></li><li><strong>Manual:</strong> See `abilities_manual.md` for more details.</li></ul></li><li><p><strong>`loadouts.gd` - `Loadouts`</strong></p><ul><li><strong>Purpose:</strong> Computes and manages the set of abilities available to a specific actor, potentially based on equipped items, class, or active status effects.</li><li><strong>Key API:</strong><ul><li>`grant()`: Grants a specific ability ID to an actor.</li><li>`get_available()`: Returns a list of all abilities an actor currently has access to.</li></ul></li><li><strong>Interaction:</strong> Primarily queried by UI systems or `TurnBasedGridTimespace` to determine an actor's available actions.</li><li><strong>API Reference:</strong> <a href="html/Loadouts.html">Loadouts API Documentation</a></li><li><strong>Manual:</strong> See `loadouts_manual.md` for more details.</li></ul></li><li><p><strong>`reactions.gd` - `Reactions`</strong></p><ul><li><strong>Purpose:</strong> Queues and resolves reactive opportunities (e.g., attacks of opportunity, counter-spells) in a First-In, First-Out (FIFO) order.</li><li><strong>Key API:</strong><ul><li>`trigger()`: Adds a reaction to the queue.</li><li>`resolve_next()`: Processes the next reaction in the queue.</li><li>`get_pending()`: Returns the list of reactions awaiting resolution.</li></ul></li><li><strong>Interaction:</strong> `TurnBasedGridTimespace` can trigger reactions based on game events (e.g., movement into line of sight).</li><li><strong>API Reference:</strong> <a href="html/Reactions.html">Reactions API Documentation</a></li><li><strong>Manual:</strong> See `reactions_manual.md` for more details.</li></ul></li><li><p><strong>`event_bus.gd` - `EventBus`</strong></p><ul><li><strong>Purpose:</strong> An append-only, structured log for all significant game events. It's fundamental for analytics, debugging, and enabling deterministic replays of game sessions.</li><li><strong>Key API:</strong><ul><li>`push()`: Adds an event dictionary to the log.</li><li>`serialize()`, `replay()`: For saving and loading event logs.</li></ul></li><li><strong>Interaction:</strong> Almost all other modules push events to the `EventBus` to maintain a comprehensive record of game state changes.</li><li><strong>API Reference:</strong> <a href="html/EventBus.html">EventBus API Documentation</a></li><li><strong>Manual:</strong> See `event_bus_manual.md` for more details.</li></ul></li></ul><h4>Integration Layer</h4><p>This module acts as a central point for wiring together the core logic services.</p><ul><li><strong>`runtime_services.gd` - `RuntimeServices`</strong><ul><li><strong>Purpose:</strong> Aggregates all core logic modules (e.g., `LogicGridMap`, `TurnBasedGridTimespace`, `Attributes`, `Statuses`, `Abilities`, `Loadouts`, `Reactions`, `EventBus`) into a single `Node`. This provides a convenient single entry point for gameplay scenes to access the entire backend logic state.</li><li><strong>Key API:</strong> Its members are direct references to instances of the other core modules (e.g., `runtime_services.grid_map`, `runtime_services.timespace`).</li><li><strong>Interaction:</strong> On `_init`, it wires `TurnBasedGridTimespace` to a `LogicGridMap` and sets up cross-module references. Its `run_tests()` method performs a minimal integration test and then executes each aggregated module's self-tests, aggregating results for CI.</li><li><strong>API Reference:</strong> <a href="html/RuntimeServices.html">RuntimeServices API Documentation</a></li></ul></li></ul><h3>UI Components</h3><p>These scripts are responsible for displaying game information and handling player input.</p><ul><li><strong>`variable_display.gd` - `VariableDisplay`</strong><ul><li><strong>Purpose:</strong> A panel script typically attached to `scenes/MainHUD.tscn`. It subscribes to `RuntimeServices` signals to display real-time game information (e.g., current round, active actor).</li><li><strong>Key API:</strong> Allows modules to register custom stats via `register_stat()` with optional formatting helpers, making it flexible for displaying various game data.</li><li><strong>Interaction:</strong> Listens to signals from `RuntimeServices` and its aggregated modules to update the UI.</li></ul></li></ul><h3>Tests</h3><p>The project includes a robust testing framework to ensure the stability and correctness of its modules.</p><ul><li><p><strong>`scripts/test_runner.gd`</strong></p><ul><li><strong>Purpose:</strong> The main headless test harness. It iterates over module instances, calls their `run_tests()` methods, prints pass/fail summaries, and exits with the number of failures.</li><li><strong>Best Practice:</strong> Each module is designed to free temporary objects to avoid memory leaks during testing.</li></ul></li><li><p><strong>`scripts/tests/grid_visual_logic_test.gd`</strong></p><ul><li><strong>Purpose:</strong> Provides a small SceneTree specifically for testing `GridVisualLogic`. It instantiates the visual logic module and exercises its color and callable drawing paths to ensure visual correctness.</li></ul></li></ul><h3>Documentation</h3><p>Existing manuals in `docs/` describe individual modules in more detail. This overview ties them together and highlights additional scripts (like `Workspace`, `GridInteractor`, `BaseActor`) that are crucial for understanding the project's structure and development workflow. Refer to the specific manual for in-depth API usage and examples for each module.</p>
    </section>
    
    ... and so on for all the other files ...

</body>
</html>
