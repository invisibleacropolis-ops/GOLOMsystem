# GridRealtimeRenderer Manual

`GridRealtimeRenderer` is a high-performance overlay renderer built for tactical grid games. It uses `MultiMeshInstance2D` to batch tile fills, allowing thousands of per-frame updates without creating individual `CanvasItem` nodes. Numeric channels can also be mapped through a `Gradient` to display heatmaps.

## Responsibilities

- Maintain a static grid of quads sized to `cell_size` and `grid_size`.
- Provide direct per-cell color fills via `set_cell_color()` and `clear_*()` helpers.
- Track arbitrary numeric channels and convert them into colors with `apply_heatmap()`.
- Optionally draw grid lines and lightweight overlays such as current actor, paths, areas of effect, and zones of control.

## Key Methods

| Method | Description |
|-------|-------------|
| `set_grid_size(w, h)` | Resizes the grid and rebuilds the multimesh. |
| `set_cell_color(p, color)` | Assigns a fill color to a tile. |
| `clear_all()` | Resets all tiles to transparent. |
| `set_channel_value(name, p, v)` | Writes a numeric value to a named channel. |
| `apply_heatmap(name, vmin, vmax, alpha)` | Maps a channel to colors using `heat_gradient`. |
| `show_path(tiles, col)` | Convenience renderer for highlighting tile arrays. |

## Usage Example

```gdscript
var grid_vis := GridRealtimeRenderer.new()
add_child(grid_vis)

# Direct colors
grid_vis.set_cell_color(Vector2i(1, 2), Color.RED)

# Heatmap
for y in range(height):
    for x in range(width):
        grid_vis.set_channel_value("danger", Vector2i(x, y), danger_value(x, y))

grid_vis.apply_heatmap("danger", 0.0, 100.0, 0.65)
```

Bulk color maps generated by the procedural world service can be applied in one
call:

```gdscript
grid_vis.apply_color_map(colors)
```

## GPU Labels

Enable `use_gpu_labels` to batch text rendering. Wrap label calls with
`begin_labels()` and `end_labels()` so all strings draw in a single pass.

```gdscript
grid_vis.begin_labels()
grid_vis.push_label("HQ", Vector2i(0,0))
grid_vis.end_labels()
```

## Vision Shaders

Call `set_shader_mode()` to switch palettes at runtime.

```
grid_vis.set_shader_mode(1) # night vision
grid_vis.set_shader_mode(2) # fog of war
```

## ASCII Debug Output

`GridRealtimeRenderer` can emit a lightweight ASCII snapshot of the grid. The
`ascii_update_sec` export controls how often the `ascii_debug` string refreshes.
Every interval the renderer prints this string, enabling headless tests or
external tools to inspect state without a visual viewport.

The snapshot now mirrors the visual renderer more closely. Characters are
assigned per cell using the same priority rules (glyph, stroke, fill, empty)
but may also include arbitrary actor symbols registered through

`set_ascii_entity()`. When `ascii_include_actors` is enabled the renderer will
scan `ascii_actor_group` every refresh and automatically insert symbols for any
nodes in that group. Each actor can override `get_ascii_symbol()`,
`get_ascii_color()`, `get_ascii_priority()` and `get_ascii_z_index()` to
customize its representation and layering. When `ascii_use_color` is enabled the output uses ANSI color
codes derived from the underlying cell color, allowing terminals to display the
map with colored glyphs.


Default layer characters:

| Char | Meaning |
|------|---------|
| `*`  | Glyph layer present |
| `#`  | Outline/stroke present |
| `+`  | Filled cell |
| `.`  | Empty |

The helper `generate_ascii_field()` can be called to obtain the current snapshot
on demand. Additional actor symbols may be injected with:

```gdscript
grid_vis.set_ascii_entity(Vector2i(1,0), "@", Color.BLUE, 10, -1, 1)
```

The optional `priority` and `z_index` parameters determine which symbol appears
when multiple entries stack in a single cell; entries sort by priority then
z-index. `set_ascii_entity` silently ignores positions that fall outside the
configured grid bounds so stray markers do not corrupt the snapshot. When
`collect_ascii_entities()` gathers actors it now respects each actor's `size`
property and optional `get_ascii_z_index()` method, stamping every cell in its
footprint. This makes multi-tile creatures render correctly in the ASCII
output.

Footprints are cached by actor so repeated casts avoid rebuilding the same
offset list each frame. When an actor is removed, `remove_ascii_actor(actor)`
can erase only its symbols without clearing the entire ASCII field. The renderer
also tracks each actor's last position and size so `collect_ascii_entities()`
only re-stamps cells for actors that moved or resized, keeping incremental
updates efficient even with large casts.

### Interactive Input

`GridRealtimeRenderer` now exposes `update_input(pos, action)` so headless tools
can mark a grid location and record the last interaction. Supported actions are
`select`, `move`, `target`, `click`, `drag_start`, `drag`, `drag_end`, and `clear`.
For example:

```gdscript
grid_vis.update_input(Vector2i(2,1), "select")
print(grid_vis.generate_ascii_field())
```

This highlights the chosen cell with an `X`. After selecting, `move` will
relocate the chosen marker, `target` paints a `T`, and `click` marks a `C`.
Drag operations stream a cyan `o` along the path between the drag start and the
current cursor location, allowing quick previews of potential routes. Begin a
drag with `drag_start`, update it with `drag`, and finalize with `drag_end`.
Paths remain until `clear` removes all markers or another drag begins.

Actors can also be polled automatically:

```gdscript
var actor := BaseActor.new()
actor.grid_pos = Vector2i(1,0)
actor.add_to_group("actors")
# GridRealtimeRenderer will pick up the actor on the next refresh.
```

```
var grid_vis := GridRealtimeRenderer.new()
grid_vis.grid_size = Vector2i(2,2)
grid_vis._ready()
grid_vis.set_cell_color(Vector2i(0,0), Color.RED)
print(grid_vis.generate_ascii_field())
```

## Testing

`GridRealtimeRenderer` includes a self-test that verifies the ASCII snapshot. Run all
module tests headlessly with:

```bash
godot4 --headless --path . --script scripts/test_runner.gd
```

